# -*- coding: utf-8 -*-
from __future__ import absolute_import

import json
import time
import urllib
import re
import hashlib

import os
import sys
from vdlib.util import filesystem
from vdlib.util import quote_plus, unquote_plus
from vdlib.util.string import decode_string

import xbmc
import xbmcgui
import xbmcplugin
import xbmcvfs
import xbmcaddon

from simpleplugin import Plugin
from torrserve.client import client, touch, http_request
from simpleplugin import Params, Plugin
from tmdb.api import TMDB
from torrserve.config import TORRSERVED_HOST, ADDON_PATH
from torrserve.utils import humanizeSize, notify, settingsIsOpen, parseName, checkMime, makeMovieItem, makeTvShowItem, get_label
from torrserve.xplayer import xPlayer
import searcher

from torrserve.simpleplugin3_suport import create_listing

if sys.version_info >= (3, 0):
    from .py3 import bencode
    str_type = str
    from urllib.parse import urlencode
else:
    str_type = unicode
    from . import bencode
    from urllib import urlencode

plugin = Plugin()
translate = plugin.initialize_gettext()
tmdb = TMDB()

def log(s):
    message = u'[{}: navigation.py]: {}'.format(plugin.id, s)
    xbmc.log(message)

def addon_img_path(filename):
    return os.path.join(ADDON_PATH, "resources", "img", filename)

def getVerTS():
    engine = client()
    if engine.is_v2:
        return 2
    else:
        return 1

@plugin.action()
def root():
    resp = client().echo()
    if not resp:
        notify(translate("Server {0} is down").format(TORRSERVED_HOST))
        listing = get_listing("noindex")
        return create_listing(listing, category="N/A")
    else:
        listing = get_listing("index")
        return create_listing(listing, category="v"+str(resp), content='videos')

def get_listing(params, type=None):
    listing = []
    if params == "index":
        listing.append({
            'label': translate("Torrents List"),
            'url': plugin.get_url(action='torrents', mod='list'),
            'icon': addon_img_path("list.png"),
            'is_folder': True
        })
        if plugin.get_setting("use_torlook", True):
          listing.append({
            'label': translate("Search"),
            'url': plugin.get_url(action="search", mod="index"),
            'icon': addon_img_path("search.png"),
            'is_folder': True
          })
        listing.append({
            'label': translate('Open .torrent'),
            'url': plugin.get_url(action='file', mod='open'),
            'icon': addon_img_path("add.png"),
            'is_folder': True,
        })
        listing.append({
            'label': translate('Open all .torrent in dir'),
            'url': plugin.get_url(action='file', mod='opendir'),
            'icon': addon_img_path("add.png"),
            'is_folder': True,
        })
        listing.append({
            'label': translate("Settings"),
            'icon': addon_img_path("settings.png"),
            'url': plugin.get_url(action='settings', mod='read'),
            'is_folder': False,
        })
    elif params == "noindex":
        listing.append({
            'label': translate("Settings"),
            'icon': addon_img_path("settings.png"),
            'url': plugin.get_url(action='settings', mod='open'),
            'is_folder': False
        })
    elif params == "search":
        langD = (('ru', 'russians'), ('en', 'english speaking'), ('fr', 'french'),
               ('de', 'german'), ('it', 'italian'), ('ja', 'japanese'),
               )
        year = time.strftime('%Y') #"2020"
        if type == "movie":
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("Movies"), translate("Cartoons"), translate("per day")),
                'url': plugin.get_url(action='search', mod='trending', type='movie', wtime='day', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("Movies"), translate("Cartoons"), translate("per week")),
                'url': plugin.get_url(action='search', mod='trending', type='movie', wtime='week', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Movies")),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Cartoons")),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Movies"), year),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Cartoons"), year),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            for l, m in langD:
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Movies"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, lang=l, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Cartoons"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, lang=l, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
            listing.append({
                "label": translate("New Search"),
                'url': plugin.get_url(action='search', mod="search", type="movie"),
                'icon': addon_img_path("search.png"),
                "is_playable": False,
                'is_folder': True,
            })
        elif type == "tvshow":
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("TV Shows"), translate("Animated series"), translate("per day")),
                'url': plugin.get_url(action='search', mod='trending', type='tvshow', wtime='day', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("TV Shows"), translate("Animated series"), translate("per week")),
                'url': plugin.get_url(action='search', mod='trending', type='tvshow', wtime='week', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("TV Shows")),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Animated series")),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("TV Shows"), year),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Animated series"), year),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            for l, m in langD:
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("TV Shows"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, lang=l, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Animated series"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, lang=l, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
            listing.append({
                "label": translate("New Search"),
                'url': plugin.get_url(action='search', mod="search", type="tvshow"),
                'icon': addon_img_path("search.png"),
                "is_playable": False,
                'is_folder': True,
            })
        else:
            listing.append({
                "label": translate("Movies"),
                'url': plugin.get_url(action='search', mod="index", type="movie"),
                'icon': addon_img_path("movies.png"),
                "is_playable": False,
                'is_folder': True,
            })
            listing.append({
                "label": translate("TV Shows"),
                'url': plugin.get_url(action='search', mod="index", type="tvshow"),
                'icon': addon_img_path("tv.png"),
                "is_playable": False,
                'is_folder': True,
            })
            listing.append({
                'label': translate("Torrents"),
                'url': plugin.get_url(action='search', mod="torrent"),
                'icon': addon_img_path("search.png"),
                'is_playable': False,
                'is_folder': True,
            })
            type='video'

        with plugin.get_storage('historySearch'+type) as storage:
            i = 0
            while i < 10:
                try:
                    if storage['title{0}'.format(i)]:
                        listing.append({
                            'label': storage['title{0}'.format(i)],
                            'url': plugin.get_url(action='search', mod="search", type=type, query=storage['title{0}'.format(i)]) if type != 'video' else plugin.get_url(action='search', mod="torrent", type=type, query=storage['title{0}'.format(i)]),
                            'icon': addon_img_path("search.png"),
                            'is_playable': False,
                            'is_folder': True,
                            "context_menu": [(
                                translate("Remove query"),
                                "RunPlugin(%s)" % plugin.get_url(action="search", mod="history", type=type, delete='title{0}'.format(i)),
                            )]
                        })
                except:
                    pass
                finally:
                    i += 1
    return listing

@plugin.action('file')
def open_file(params):
    dialog = xbmcgui.Dialog()
    if params.link and params.link.startswith('http'):
        import requests
        r = requests.get(params.link)
        if r.ok:
            data = r.content
            if not data:
                return
            pFile = 'special://temp/torrserve.torrent'
            tFile = xbmc.translatePath(pFile)
            rtFile = tFile.decode('utf8')
            file(rtFile, 'wb').write(data)
        else:
            return
    else:
        tFile = dialog.browseSingle(1, translate('Select torrent file'), 'files', '.torrent')
        #dialog.ok('test', tFile)
    if tFile != '':
        listing = []
        tfiles = [tFile]
        if params.mod == 'opendir':
            dir = tFile[:tFile.rfind('/')]
            dirs, files = xbmcvfs.listdir(dir)
            files.sort()
            #dialog.ok('test', str_type(files))
            tfiles = [os.path.join(dir, i) for i in files if '.torrent' in i.lower()]
        for tfile in tfiles:
            tf = xbmcvfs.File(tfile)
            i = tf.read()
            tf.close()
            metainfo = bencode.bdecode(i)
            infohash = hashlib.sha1(bencode.bencode(metainfo['info'])).hexdigest()
            tr = [metainfo['announce']]
            if 'announce-list' in metainfo:
                for t in metainfo['announce-list']:
                    if t: 
                        tr.append(t.pop())
            params = {
                'dn': metainfo['info']['name'],
                'tr': tr,
            }
            magneturi = 'magnet:?xt=urn:btih:{0}&{1}'.format(str(infohash).upper(), urlencode(params, True))
            listing.append({
                'label': metainfo['info']['name'],
                'url': plugin.get_url(action='gotInfo', magnet=magneturi),
                'icon': addon_img_path("magnet.png"),
                'is_folder': True,
                "context_menu": [(
                    translate("Add to DB"),
                    "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magneturi),
                )]
            })
        return create_listing(listing, cache_to_disk=True, category=tFile)

def pNone(p):
    return p if p !='None' else None

@plugin.action("search")
def search(params):
    poster = None
    listing = []
    if params.mod == "index":
        return create_listing(get_listing("search", params.type))
    elif params.mod == "history":
        with plugin.get_storage('historySearch'+params.type) as storage:
            storage[params.delete] = None
        xbmc.executebuiltin("Container.Refresh")
        return
    elif params.mod in ("discover","trending"):
        result = {}
        page = params.page
        query = pNone(params.year)
        lang = pNone(params.lang)
        genres = pNone(params.genres)
        ngenres = pNone(params.ngenres)
        nextPage = int(page) + 1
        if params.type == "movie":
            if params.mod == "discover":
               result = tmdb.discover_movie(query, page, lang, genres, ngenres)
            else:
               result = tmdb.trending(mtype="movie", wtime=params.wtime, page=page)
            movie_ids = result['results']
            for movie in movie_ids:
                item = makeMovieItem(movie)
                item.update({'url': plugin.get_url(action='search', 
                                                    mod="torrent", 
                                                    query=u'{} {}'.format(movie['original_title'], str(movie['release_date'][:4])), 
                                                    type="movie", 
                                                    id=movie['id']),
                    'context_menu': [( translate('Search title and year'),
                        'Container.Update(%s)' % plugin.get_url(action='search', 
                                                            mod="torrent", 
                                                            query=u'{} {}'.format(movie['title'], str(movie['release_date'][:4])), 
                                                            type="movie", 
                                                            id=movie['id'], 
                                                            title='true')),
                                    ( translate('Search title'),
                        'Container.Update(%s)' % plugin.get_url(action='search', 
                                                            mod="torrent", 
                                                            query=u'{} {}'.format(movie['title'], str(movie['release_date'][:4])), 
                                                            type="movie", 
                                                            id=movie['id'], 
                                                            title='onlyname'),
                    )],
                })
                listing.append(item)
        elif params.type == "tvshow":
            if params.mod == "discover":
               result = tmdb.discover_tvshow(query, page, lang, genres, ngenres)
            else:
               result = tmdb.trending(mtype="tv", wtime=params.wtime, page=page)
            shows_ids = result['results']
            for show in shows_ids:
                item = makeTvShowItem(show)
                item.update({'url': plugin.get_url(action='search', mod="torrent", query=show['original_name'].encode('utf-8'), type="tvshow", id=show['id']),
                'context_menu': [( translate('Search title'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=show['name'].encode('utf-8'), type="tvshow", id=show['id'], title='true'),
                    )],
                })
                listing.append(item)
        maxPage = int(result.get('total_pages', '1'))
        if nextPage <= maxPage:
           listing.append({
              'label': "{0} / ({1})".format(translate("Next page ({0})").format(nextPage), maxPage),
              'icon': addon_img_path("nextpage.png"),
              'url': plugin.get_url(action='search', mod='discover', type=params.type, page=nextPage, year=query, lang=lang, genres=genres, ngenres=ngenres)
           })
        return create_listing(listing, category="{0}: {1}".format(translate("Discover"), query), cache_to_disk=True, content="{0}s".format(params.type), view_mode=plugin.get_setting('search_view'))
    elif params.mod == "search":
        result = {}
        query = params.query
        dialog = xbmcgui.Dialog()
        if not query:
            query = dialog.input("Yohoho", type=xbmcgui.INPUT_ALPHANUM)
            if query == "":
                return
            with plugin.get_storage('historySearch'+params.type) as storage:
                storage['title9'] = storage.get('title8')
                storage['title8'] = storage.get('title7')
                storage['title7'] = storage.get('title6')
                storage['title6'] = storage.get('title5')
                storage['title5'] = storage.get('title4')
                storage['title4'] = storage.get('title3')
                storage['title3'] = storage.get('title2')
                storage['title2'] = storage.get('title1')
                storage['title1'] = storage.get('title0')
                storage['title0'] = query
        if params.type == "movie":
            result = tmdb.search_movies(query, params.page)
        else:
            result = tmdb.search_tv_shows(query, params.page)
        maxPage = int(result['total_pages'])
        nextPage = int(result['page'])+1
        movie_ids = result['results']
        for movie in movie_ids:
            if params.type == "movie":
                item = makeMovieItem(movie)
                item.update({'url': plugin.get_url(action='search', mod="torrent", query=movie['original_title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id']),
                'context_menu': [( translate('Search title and year'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id'], title='true') ),
                    ( translate('Search title'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id'], title='onlyname'),
                    )],
                })
                listing.append(item)
            elif params.type == "tvshow":
                if movie['number_of_seasons'] > 0:
                    item = makeTvShowItem(movie)
                    item.update({
                        'url': plugin.get_url(action='search', mod="torrent", query=movie['original_name'].encode('utf-8'), type="tvshow", id=movie['id']),
                        'context_menu': [( translate('Search title'),
                            'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['name'].encode('utf-8'), type="tvshow", id=movie['id'], title='true'),
                            )],
                    })
                    listing.append(item)
        if nextPage <= maxPage:
           listing.append({
             'label': "{0} / ({1})".format(translate("Next page ({0})").format(nextPage), maxPage),
             'icon': addon_img_path("nextpage.png"),
             'url': plugin.get_url(action='search', mod='search', type=params.type, query=query, page=nextPage)
           })
        return create_listing(listing, category="{0}: {1}".format(translate("Search"), query), cache_to_disk=True, content="{0}s".format(params.type), view_mode=plugin.get_setting('search_view'))
    elif params.mod == "torrent":
        import vsdbg
        vsdbg.breakpoint()

        selSeason = params.selSeason
        ext_info = ""
        query = params.query
        if query is None:
            params.type = "video"
            dialog = xbmcgui.Dialog()
            query = dialog.input(translate("Torrents"), type=xbmcgui.INPUT_ALPHANUM)
            if query == "":
                return
            with plugin.get_storage('historySearch'+params.type) as storage:
                storage['title9'] = storage.get('title8')
                storage['title8'] = storage.get('title7')
                storage['title7'] = storage.get('title6')
                storage['title6'] = storage.get('title5')
                storage['title5'] = storage.get('title4')
                storage['title4'] = storage.get('title3')
                storage['title3'] = storage.get('title2')
                storage['title2'] = storage.get('title1')
                storage['title1'] = storage.get('title0')
                storage['title0'] = query
        if params.type == "tvshow" and params.title:
            ext_info = tmdb.get_tv_show(params.id)
            selSeason = ""
            query = ext_info['name'].encode('utf-8')
        elif params.type == "tvshow" and selSeason is None:
            ext_info = tmdb.get_tv_show(params.id)
            listing = []
            for number in range(1, ext_info['number_of_seasons']+1, 1):
                item = makeTvShowItem(ext_info, "season", number)
                item.update({
                    'url': plugin.get_url(action='search', mod=params.mod, type=params.type, id=params.id, query=params.query, selSeason=number)
                })
                listing.append(item)
            return create_listing(listing, cache_to_disk=True, sort_methods=xbmcplugin.SORT_METHOD_LABEL, content="{0}s".format(params.type))
        elif params.type == "tvshow" and selSeason:
            ext_info = tmdb.get_tv_show(params.id)
            selSeason = "{0:02d}".format(int(selSeason))
            query = ext_info['original_name'].encode('utf-8')
        elif params.type == "movie":
            ext_info = tmdb.get_movie(params.id)
            if params.title:
                  query = "{0}".format(ext_info['title'].encode('utf-8'))
            else:
                  query = "{0}".format(ext_info['original_title'].encode('utf-8'))
            if params.title == "onlyname":
                  pass
            else:
                  query = query + " ({0})".format(ext_info['release_date'][:4])

        if True:
            query = decode_string(query)
            result = searcher.Query(query)
            if not result:
                notify(translate("Empty result")+" "+query)
                return

        for t in result:
            magnet    = t['url']
            name      = t['title']
            trackers  = "rutor,torlook"
            stringSize= t['size']
            seeds = t['sids']
            name = name.replace("<b>", "").replace("</b>", "")
            item = dict()
            size = ""

            if not isinstance(stringSize, basestring):
                size = int(stringSize)
                stringSize = humanizeSize(stringSize).encode('utf8')
            elif stringSize[stringSize.rfind(' ')+1:] in ['МБ', 'MB']:
                size = int(float(stringSize[:stringSize.rfind(' ')]) * float(2 << 19))
            else:
                size = int(float(stringSize[:stringSize.rfind(' ')]) * float(2 << 29))
            context_menu = [(
                translate("Add to DB"),
                "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magnet),
            )]
            if params.type == 'movie':
                if name.find(query) == -1 and not (name.find(query.split('(')[0])>-1 and (name.find(query.replace('(','([').split('(')[1].strip(' )'))>-1 or name.find(query.replace('(','((').split('(', 1)[1].strip())>-1 or name.find(query.replace('(','(/ ').split('(', 1)[1].strip().replace(')',' /'))>-1)):
                    continue
                item = makeMovieItem(ext_info, False, size)
                poster = item['art'].get('poster')
                context_menu = [(
                    translate("Add to DB"),
                    "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magnet, info=json.dumps({'kodi':{'info': item['info']['video'], 'cast':item['cast']}, 'poster_path':item['art']['poster'] }) ),
                )]
                context_menu.append((
                    translate('Save to Library'),
                    'RunPlugin({0})'.format(plugin.get_url(action='library', mod='save', id=ext_info['id'], year=ext_info['release_date'][:4], magnet=magnet, item=repr(item)))
                ))
            elif params.type == 'tvshow':
                numEp = ""
                numSeason = selSeason[1:] if selSeason and selSeason.startswith('0') else selSeason
                if query in name and name.find('S'+selSeason) > -1:
                    if '[S'+selSeason+']' in name:
                        numEp = "All"
                    elif '[S01-' in name:
                        numEp = "Multi"
                    else:
                        numEp = name[name.find('S'+selSeason)+4:name.find('S'+selSeason)+6]
                elif query in name and name.find(selSeason+'x') > -1:
                    numEp = name[name.find(selSeason+'x')+6:name.find(selSeason+'x')+8]
                    if 'и' in numEp:
                        numEp = name[name.find(selSeason+'x')+3:name.find(selSeason+'x')+5]
                elif query in name and name.find('['+selSeason+'-') > -1:
                    numEp = name[name.find('['+selSeason+'-')+4:name.find('['+selSeason+'-')+6]
                elif query in name and name.find('Сезон: '+numSeason) > -1:
                    fk = 'Сезон: '+numSeason
                    sk = name.find(fk)
                    if name[sk+len(fk):sk+len(fk)+1].isdigit(): continue
                    numEp = 'Multi' #TODO
                elif query in name and (name.find(numSeason+' сезон') > -1 or name.find('сезон '+numSeason) > -1):
                    fk = 'сезон '+numSeason
                    sk = name.find(fk)
                    if sk > -1 and name[sk+len(fk):sk+len(fk)+1].isdigit(): continue
                    numEp = 'Multi'
                else: 
                    continue
                if params.selSeason:
                     item = makeTvShowItem(ext_info, "season", int(params.selSeason), True, size)
                else:
                     item = makeTvShowItem(ext_info, "tvshow", None, True, size)
                poster = item['art'].get('poster')
                context_menu = [(
                    translate("Add to DB"),
                    "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magnet, info=json.dumps({'kodi':{'info': item['info']['video'], 'cast':item['cast']}, 'poster_path':item['art']['poster'] }) ),
                )]
                context_menu.append((
                    translate('Save to Library'),
                    'RunPlugin({0})'.format(plugin.get_url(action='library', mod='save', id=ext_info['id'], year=ext_info['first_air_date'][:4], magnet=magnet, season=selSeason, numEp=numEp, item=repr(item)))
                ))
            label = get_label(name)
            name = "[B]{1}[COLOR=FFFFFFFF]/{0}/[/COLOR][/B][COLOR=FFFFFFFF]{3}/[/COLOR] {2}".format(stringSize.replace(' ', ''), label, name, seeds)
            stream_info = ""
            if '2160' in label:
                stream_info = {'video': {'width': 3840, 'height': 2160}}
            elif '1080' in label:
                stream_info = {'video': {'width': 1920, 'height': 1080}}
            elif '720' in label:
                stream_info = {'video': {'width': 1280, 'height': 720}}
            else:
                stream_info = ""
            context_menu.append((
                translate('Open TAM'),
                'RunPlugin({0})'.format(plugin.get_url(action='tam', magnet=magnet)),
            ))
            item.update({
                "label": name,
                'url': plugin.get_url(action='gotInfo', magnet=magnet, poster=poster) if poster else plugin.get_url(action='gotInfo', magnet=magnet),
                'is_folder': True,
                "context_menu": context_menu,
                'stream_info': stream_info
            })
            listing.append(item)
        view_mode = plugin.get_setting('result_view')
        if params.usearch == 'True': view_mode = '0'
        return create_listing(listing, category="{0}".format(translate("Search")), cache_to_disk=True, sort_methods=(xbmcplugin.SORT_METHOD_LABEL, xbmcplugin.SORT_METHOD_SIZE), content="{0}s".format(params.type), view_mode=view_mode)

@plugin.action('descript')
def descript(params):
    gui = GuiTextViewer('DialogTextViewer.xml', sys.argv[0], descript=params.text, title=translate("Description"))
    gui.doModal()
    del gui


class GuiTextViewer(xbmcgui.WindowXMLDialog):
    def __init__(self, *args, **kwargs):
        self.descript = kwargs['descript']
        self.title = kwargs['title']
        xbmcgui.WindowXMLDialog.__init__(self, *args, **kwargs)
    
    def onInit(self):
        #lang = Lang()
        self.getControl(1).setLabel(self.title)
        self.getControl(5).setText(self.descript)
    
    def onFocus(self, control):
        pass


def checkMagnet(magneturi):
    kinozalurl = plugin.get_setting("kinozal_url")
    if not magneturi:
            pass
    elif '://torlook.info/dl/' in magneturi:
            html = http_request('', host=magneturi, ljs=False)
            r = re.compile(r"(magnet:.+?)'>").search(html)
            if not r:
                return
            magneturi = r.group(1)
    elif '://kinozal-tv.appspot.com/magnet?' in magneturi or (kinozalurl.strip() !="" and '://'+kinozalurl.strip()+'/magnet?' in magneturi):
            from searcher.scrapers.kinozal import get_magnet as kz_magnet
            magneturi = kz_magnet(magneturi.split('magnet?')[1])
    elif magneturi.startswith('http'):
            data = http_request('', host=magneturi, ljs=False)
            if not data:
               return
            try:
               metainfo = bencode.bdecode(data)
            except BaseException as e:
               if data.find('keywords" content="nnm-club,') != -1:

                  r = re.compile(r'name="redirect"\s+value="([^"]+)"').search(data)
                  if not r:
                     return
                  redirect = r.group(1)
                  from searcher.scrapers.nnmclub import Tracker
                  login = plugin.get_setting("nnmclub_login")
                  password = plugin.get_setting("nnmclub_password")
                  if login == "" or password == "":
                      notify("Нужен логин и пароль NNMClub для просмотра раздачи")
                      return
                  data2 = Tracker().Login(login, password, redirect)
                  if data2.find('keywords" content="nnm-club,') != -1:
                      notify("Неверный логин и пароль от NNMClub")
                      return

                  metainfo = bencode.bdecode(data2)


               else:
                  notify(str(e))
            infohash = hashlib.sha1(bencode.bencode(metainfo['info'])).hexdigest()
            tr = [metainfo['announce']]
            if 'announce-list' in metainfo:
                for t in metainfo['announce-list']:
                    if t: tr.append(t.pop())
            mparams = {
            'dn': metainfo['info']['name'],
            'tr': tr,
            }
            magneturi = 'magnet:?xt=urn:btih:{0}&{1}'.format(str(infohash).upper(), urlencode(mparams, True))
    return magneturi

def makeTorrentsList():
    #request = int(plugin.get_setting("without_info", True))
    #response = client("/torrent/shortlist", post_data={"Request": request, "Info": 1})
    #if response is None: 

    response = client().list()  #("/torrent/list", post_data={"Request": request})
    for torrent_item in response:
        engine = client(hash=torrent_item['Hash'])

        title = torrent_item.get('title')
        label = parseName( title if title else torrent_item['Name']) 
        size = torrent_item.get('Length')
        if size:
            size = humanizeSize(size)
        item = {
            "label": u"[{0}] {1}".format(size, label) if size else label,
            "url": plugin.get_url(action="torrents", mod="files", hash=torrent_item['Hash']),
            "icon": addon_img_path("magnet.png"),
            "context_menu": [(  
                translate("Delete from DB"),
                "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="delete", hash=torrent_item["Hash"]),
            ), (
                translate("Open TAM"),
                "RunPlugin(%s)" % plugin.get_url(action="tam", hash=torrent_item["Hash"], name=label.encode('utf8', 'replace')),
            )],
        }

        info = None
        data = torrent_item.get('data', torrent_item.get('Info'))
        if data:
            try:
                info = json.loads(data)
            except json.JSONDecodeError:
                data = None

        poster = torrent_item.get('poster')
        if poster:
            art = {
                'thumb': poster,
                'poster': poster,
            }
            if info:
                art['fanart'] = info.get('backdrop_path')
        else:
            art = None # engine.get_art()

        if art:
            log('Has art')
            log(str_type(art))
            item.update({'art': art})
            if 'thumb' in art:
                item['icon'] = art['thumb']

        if data:
            video_info = engine._get_video_info_from_data(data)
        else:
            video_info = None #engine.get_video_info()

        if video_info:
            log('Has video info')
            log(str_type(video_info))
            if 'info' in item and item['info'].get('video'): 
                video_info['mediatype'] = "movie"
            item['info'] = { 'video': video_info }

        if 'Info' in torrent_item and torrent_item['Info'] != "{}":
            i = json.loads(torrent_item['Info'])
            if 'descript' in i:
                item['context_menu'].insert(0,(
                    translate("Description"),
                    "RunPlugin(%s)" % plugin.get_url(action="descript", text=i['descript'].encode('utf8', 'replace')),
                ))

            if 'kodi' in i:
                if 'info' in i['kodi'] and i['kodi'].get('info'):
                    item['info'] = { 'video': i['kodi']['info'] }
                if 'cast' in i['kodi'] and i['kodi'].get('cast'):
                    item['cast'] = i['kodi']['cast']
        yield item

def makeFileList(hash):
    onlymedia = plugin.get_setting("only_media", True)
    engine = client(hash=hash)
    engine._wait_for_data()

    video_info = engine.get_video_info()
    art = engine.get_art()

    files = engine.files()
    for f in files:
        log(str_type(f))

        if onlymedia and checkMime(f['path']) == "*/*":
            continue

        item = {
            "label": parseName(f['path'].split('/')[-1]),
            "url": plugin.get_url(action="play", sort_index=f['file_id'], name=f['path'], hash=hash),
            "is_playable": True,
            "info": {"video": video_info}
        }
        if art:
            item.update({'art': art})

        yield item

@plugin.action("torrents")
def torrents(params):
    listing = []
    view_mode = '0'
    if params.mod == "list":
        listing = makeTorrentsList()
    elif params.mod == "files":
        listing = makeFileList(params.hash)
        view_mode = plugin.get_setting('files_view')
    elif params.mod == "add":
        magneturi = checkMagnet(params.magnet)
        client.add(magneturi, params.info.get('title'), params.info.get('poster'))
        notify(translate("Saved!"))
    elif params.mod == "delete":
        client.rem(params.hash)
        notify(translate("Deleted!"))
        xbmc.executebuiltin("Container.Refresh")

    if listing:
        create_listing(listing, content="videos", category="Torrents", view_mode=view_mode)

@plugin.action()
def settings(params):
    plugin.addon.openSettings()
    '''
    if params.mod == "read":
        if getVerTS() != 1:
            plugin.addon.openSettings()
            return
        resp = client("/settings/read", post_data={"read": 1})
        for k, v in resp.items():
            if k == "CacheSize" or k == "PreloadBufferSize":
                v = (v / 1024) / 1024
            plugin.set_setting(k, str(v).lower())
        plugin.addon.openSettings()
        while settingsIsOpen():
            continue

        jset = {
            "CacheSize": plugin.get_setting("CacheSize", True) * 1024 * 1024,
            "PreloadBufferSize": plugin.get_setting("PreloadBufferSize", True) * 1024 * 1024,
            "RetrackersMode": plugin.get_setting("RetrackersMode", True),
            "DisableTCP": plugin.get_setting("DisableTCP", True),
            "DisableUTP": plugin.get_setting("DisableUTP", True),
            "DisableUPNP": plugin.get_setting("DisableUPNP", True),
            "DisableDHT": plugin.get_setting("DisableDHT", True),
            "DisableUpload": plugin.get_setting("DisableUpload", True),
            "Encryption": plugin.get_setting("Encryption", True),
            "DownloadRateLimit": plugin.get_setting("DownloadRateLimit", True),
            "UploadRateLimit": plugin.get_setting("UploadRateLimit", True),
            "ConnectionsLimit": plugin.get_setting("ConnectionsLimit", True),
            "PeersListenPort": plugin.get_setting("PeersListenPort", True)
        }
        for i in ("EnableIPv6","DhtConnectionLimit","TorrentDisconnectTimeout","M3UContentType","SupportMode",
                  "DisableRealId","RequestStrategy","BuiltinRetrackers","NewtrackonRetrackers","MigrateDB",
                  "NgosangallipRetrackers","MaxRunTorrents","DelMaxRunTorrent","RemoveViewed","RemoveInfo",
                  "DisableCtrlViewed"):
               if i in resp: jset[i] = plugin.get_setting(i, True)
        if not resp == jset:
            resp = client("/settings/write", post_data=jset)
            if resp == "Ok":
                notify(translate("Settings saved! Restart service"))
                client.restart()
                xbmc.executebuiltin("Container.Refresh")
            else:
                notify(translate("Settings not saved!"))
                plugin.log_error(repr(resp))
    elif params.mod == "open":
        plugin.addon.openSettings()
    '''

def getHash(mag):
    if mag.startswith("magnet%"):
         mag = unquote_plus(mag)
    return mag[20:60]

class OurDialogProgress(xbmcgui.DialogProgress):
    def create(self, heading, line1="", line2="", line3=""):
        try:
            xbmcgui.DialogProgress.create(self, heading, line1, line2, line3)
        except TypeError:
            message = line1
            if line2:
                message += '\n' + line2
            if line3:
                message += '\n' + line3
            xbmcgui.DialogProgress.create(self, heading, message)

    def update(self, percent, line1="", line2="", line3=""):
        try:
            xbmcgui.DialogProgress.update(self, percent, line1, line2, line3)
        except TypeError:
            message = line1
            if line2:
                message += '\n' + line2
            if line3:
                message += '\n' + line3
            xbmcgui.DialogProgress.update(self, percent, message)


def prebuffer(engine):
    pDialog = OurDialogProgress()
    pDialog.create("TorrServer", 
            translate("Wait for info..."), 
            translate("Connected: {0} | Active: {1} | Total: {2}").format(0, 0, 0))

    while True:
        if pDialog.iscanceled() :
            pDialog.close()
            engine.drop()
            return False

        time.sleep(0.5)
        try:
            st = engine.stat()
        except BaseException as e:
            log('continue...')
            log(str_type(e))
            continue

        if 'message' in st:
            continue

        stat_id = st.get('TorrentStatus')

        if stat_id > 2 and engine.is_v2:
            pDialog.close()
            return True

        downSpeed = humanizeSize(st.get('DownloadSpeed', 0))
        preloadedBytes = st.get('PreloadedBytes', 0)
        preloadSize = st.get('PreloadSize', 0)
        line2 = translate("Connected: {0} | Active: {1} | Total: {2}").format(
            st.get('ConnectedSeeders', 0),
            st.get('ActivePeers', 0),
            st.get('TotalPeers', 0))

        line3 = u"D: {0}/{3} [{1}/{2}]".format(
            downSpeed, 
            humanizeSize(preloadedBytes), 
            humanizeSize(preloadSize),
            's'
        )

        if preloadSize > 0 and preloadedBytes > 0:
            prc = preloadedBytes * 100 / preloadSize
            if prc > 100:
                prc = 100
            pDialog.update(int(prc), line2, line3)

            #stat_s = st.get('TorrentStatusString')

            if  (preloadedBytes >= preloadSize) or \
                (prc > 0 and stat_id != 2): # 2 - 'Torrent preload'
                pDialog.close()
                return True


@plugin.action("play")
def play(params):
    _play(params.hash, int(params.sort_index), params)

def get_torrspy_base_path():
    try:
        torr_spy = xbmcaddon.Addon('script.service.torrspy')
        return torr_spy.getSetting('base_path')
    except RuntimeError:
        pass

def load_info_from_data(info_str, hash):
    log('load_info_from_data')
    try:
        torr_spy = xbmcaddon.Addon('script.service.torrspy')

        base_path = torr_spy.getSetting('base_path')
        path = filesystem.join(base_path, '.data', '{}.{}.json'.format(hash, info_str))

        log('load_info_from_data path is {}'.format(path))

        if filesystem.exists(path):
            log('Video info was found in {}'.format(path))

            import json
            with filesystem.fopen(path, 'r') as data:
                info = json.load(data)
                return info
    except RuntimeError:
        pass

    return {}

def load_info(info_str, hash, kodi_db):
    info = load_info_from_data(info_str, hash)
    if kodi_db:
        pass

    return info

def _play(hash, sort_index, params):
    from vdlib.kodi.kodidb import KodiDB

    log(hash)
    engine = client(hash=hash, log=log)
    engine.start(sort_index)
    #subtitles = loadsubtitles(hash, params.link),    
    success = prebuffer(engine)
    if success:
        player = xPlayer(hash=hash, index=sort_index)
        playable_url = engine.play_url(sort_index)
        # label = engine.title
        # video_info = engine.get_video_info()
        # art = engine.get_art()

        strm_path = None
        if 'strm_path' in params:
            torrspy_base_path = get_torrspy_base_path()
            strm_path = filesystem.join(torrspy_base_path, params['strm_path'])

        # vi = load_info('video_info', hash, kodi_db)
        # if not video_info:
        #     video_info = vi
        # else:
        #     video_info.update(vi)

        #_art = load_info('art', hash, kodi_db)
        #if not art:
        #    art = _art
        #else:
        #    art.update(_art)

        #if 'title' in video_info and video_info['title']:
        #    label = video_info['title']

        item = xbmcgui.ListItem(path=playable_url)

        # item = xbmcgui.ListItem(path=playable_url, label=label)
        # item.setInfo('video', video_info)
        # if art: item.setArt(art)
        
        #if subtitles:    
        #    item.setSubtitles(subtitles)

        resume_time = 0
        filedetails = {}
        if strm_path:
            from vdlib.kodi.jsonrpc_requests import Files
            result = Files.GetFileDetails(file=strm_path, media='video',
                                            properties=['playcount', 'resume'])
            if result:
                filedetails = result['filedetails']
                resume_time = filedetails.get('resume', {}).get('position', 0)
        log('resume_time is {}'.format(resume_time))

        xbmcplugin.setResolvedUrl(int(sys.argv[1]), success, item)

        while not player.isPlaying() and not xbmc.Monitor().abortRequested():
            xbmc.sleep(100)

        log('!!!!!!!!!!!!!!!!! Start PLAYING !!!!!!!!!!!!!!!!!!!!!')

        if resume_time:
            while player.isPlaying() and player.getTime() < 20:
                if player.isPlaying() and player.getTime() > 2:
                    log('Try change time pos')
                    player.seekTime(resume_time)
                    xbmc.sleep(5000)
                xbmc.sleep(1000)

        # Wait until playing finished or abort requested
        while player.isPlaying() and not xbmc.Monitor().abortRequested():
            xbmc.sleep(1000)            
            # if strm_path:
            #     Files.SetFileDetails(file=strm_path, media='video')

        log('!!!!!!!!!!!!!!!!! END PLAYING !!!!!!!!!!!!!!!!!!!!!')


@plugin.action("play_now")
def play_now(params):
    hash = getHash(params.magnet)
    save_in_db = plugin.get_setting("save_in_db", True)
    sort_index = int(params.selFile)

    #subtitles = loadsubtitles(getHash(params.magnet), fileid = params.selFile)

    _play(hash, sort_index, params)

    if not save_in_db:
        engine = client(hash=hash)
        engine.rem()

@plugin.action('play_strm')
def play_strm(params):
    from torrserve_stream import Engine

    play_url = params.play_url
    hash = Engine.extract_hash_from_play_url(play_url)
    save_in_db = plugin.get_setting("save_in_db", True)

    _play(hash, int(params.sort_index), params)

    if not save_in_db:
        engine = client(hash=hash)
        engine.rem()

@plugin.action("gotInfo")
def gotInfo(params):
    magneturi = checkMagnet(params.magnet)
    if not magneturi:
       return
    pDialog = xbmcgui.DialogProgress()
    pDialog.create("TorrServer", translate("Wait for info..."))
    listing = []
    success = False
    i = 0

    import datetime
    first_time = datetime.datetime.now()

    engine = client()
    engine.add(magneturi, poster=params.get('poster'))

    def make_item(file):
        item = {
            "label": file['path'].split('/')[-1],
            "url": plugin.get_url(action="play_now", 
                                    magnet=magneturi, 
                                    selFile=file['file_id']),
            "is_playable": True,
            "info": {"video": {
                'size': file['size'],
            }}
        }
        if params.poster:
            item.update({'art': {
                'thumb': params.poster,
                'poster': params.poster,
            }})
        return item

    while not pDialog.iscanceled():
        xbmc.sleep(500)
        stat = engine.stat()
        #if stat is None or len(stat['FileStats']) == 0:
        if stat['TorrentStatusString'] != 'Torrent working':
            xbmc.sleep(500)
            now_time = datetime.datetime.now()
            difference = now_time - first_time
            mins, secs = divmod(difference.seconds, 60)
            procents = difference.seconds * 2
            if difference.seconds > 100:
                pDialog.update(procents, 'Информация о [B]{2}[/B] не получена за {0:02d} : {1:02d} с.'.format(
                                                mins, 
                                                secs, 
                                                stat.get('Name', 'раздаче')), 
                                    'Видимо это мертвая раздача и отсутствуют пиры.')
            else:
                pDialog.update(procents, 'Пытаемся подключиться к раздаче [B]{0:02d} : {1:02d}[/B] с.'.format(
                                                mins, secs))
            continue
        else:
            files = engine.files()
            for file in files:
                if file['path'].find('/BDMV/') > 0:
                    if int(file['size']) > 1073741824 or file['path'].find('/BDMV/index.bdmv') > 0:
                        listing.append(make_item(file))
                elif checkMime(file['path']) in ("video/*", "audio/*"):
                    listing.append(make_item(file))
            success = len(listing) > 0
            pDialog.close()
            break

    if success:
        return create_listing(listing, content="videos", category="Файлы", succeeded=success)
    else:
        return create_listing(listing, succeeded=success)

def cleanname(s):
    for i in (' ','%','!','*',"'",'(',')',';',':','@','&','=','+','$',',','/','?','#','[',']','~','"','{','}'):
         s = s.replace(i,'_')
    s = s.replace('__','_')
    if isinstance(s, unicode): s = s.encode('utf8')
    return s


def loadsubtitles(hash=None, link=None, fileid=None):
    if hash and (link or fileid) and plugin.get_setting('use_subtitles', True):
        log('-- loadsubtitles start --')
        success = False
        global self_prev_name, self_rus
        self_prev_name = ''
        self_rus = ''

        def cfname(name, rus=''):
            global self_prev_name, self_rus
            if '/' in name: name = name.split('/')[-1]
            if (name == self_prev_name) and (rus == self_rus): name = name[:name.rfind('.')] + u'_2_' + name[name.rfind('.'):]
            self_prev_name = name
            self_rus = rus
            if rus and (rus.lower() not in name.lower()): name = name[:name.rfind('.')] + rus + name[name.rfind('.'):]
            elif rus and (rus.lower() in name.lower()): name = name.replace(rus.lower(), rus).replace(rus.upper(), rus)
            return name

        if link:
            fname = link.split('/')[-1]
            if '/preload/' not in link: fname = fname.split('?')[0]
            fname = unquote_plus(fname)
            if isinstance(fname, unicode): fname = fname.encode('utf8')
        stat = {}
        counter = 0
        pdialog = xbmcgui.DialogProgress()
        pdialog.create('TorrServer', translate('Start find subtitles...'))
        while not stat.get('FileStats'):
            if pdialog.iscanceled():
                pdialog.close()
                return False
            prc = counter*100/120
            pdialog.update(prc, translate('Find subtitles...'))
            stat = client(hash=hash).stat()
            if stat is None:
                stat = {}
            if counter > 120:
                pdialog.close()
                return False
            counter += 1
            time.sleep(0.5)

        self_filestats = stat['FileStats']
        ind = 0
        self_index = ind
        findfullname = None
        for f in self_filestats:
            if fileid:
                if int(f['Id']) == int(fileid):
                    findfullname = f['Path']
                    self_index = ind
            elif link:
                if cleanname(f['Path']) == fname:
                    findfullname = f['Path']
                    self_index = ind

            ind += 1
            if not findfullname:
                pdialog.close()
                return False
        findname = findfullname
        if '/' in findname:
                findname = findname.split('/')[-1]
        findname = findname[:findname.rfind('.')]

        index = 0
        temp_list = []
        for i in self_filestats:
            name = i['Path']
            if findname in name:
                if index != self_index:
                    if '.' in name:
                        ext = name.split('.')[-1]
                        if ext in ('srt', 'ass', 'ssa', 'smi'):
                            fileid = int(i['Id'])
                            temp_list.append( (index, fileid, name) )
            index += 1
        log('--sort subtitles--')
        if temp_list !=[]:
            temp_rus = []
            temp_eng = []
            temp_other = []
            del_list = []
            for f in range(len(temp_list)):
                i = temp_list[f]
                n = i[2].lower()
                if '/rus/' in n:
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    del_list.insert(0, f)
                elif '/eng/' in n:
                    temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                    del_list.insert(0, f)
            for i in del_list: del temp_list[i]
            for i in temp_list:
                n = i[2].lower()
                if ('.rus' in n) or ('_rus' in n) or ('_ru.' in n):
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                elif ('.eng' in n) or ('_eng' in n): temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                elif 'rus ' in n:
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                elif 'eng ' in n: temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                else: temp_other.append( (i[0], i[1], cfname(i[2]), i[2] ) )
            if temp_rus == [] and temp_other:
                i = temp_other[0]
                temp_rus.append( (i[0], i[1], cfname(i[3], '.Rus'), i[3] ) )
                del temp_other[0]
            temp_l = []
            temp_l.extend(temp_rus)
            temp_l.extend(temp_eng)
            temp_l.extend(temp_other)

            subtitles = []
            counter = 1
            for i in temp_l:
                uname = "/torrent/view/"+str(hash).lower()+"/"+quote_plus( cleanname(i[3]) )
                prc = counter*100/len(temp_l)
                pdialog.update(prc, translate('Load subtitles {0} / {1}').format(counter,len(temp_l)) )
                data = client(uname)
                if data:
                    class Handler:
                        @staticmethod
                        def path(*path):
                            p = [xbmc.translatePath('special://temp').decode('utf8')]
                            p.extend(path)
                            return os.path.join(*p)
                    sdir  = Handler().path('subtitles_torrserve')
                    if not os.path.isdir(sdir): os.mkdir(sdir)
                    fname = Handler().path('subtitles_torrserve', i[2])
                    with open(fname, 'wb') as file:
                        file.write(data)
                    subtitles.append(fname)
                else:
                    log('error loading subtitles!')
                    success = False
                    break
            if subtitles !=[]: success = subtitles
        else:
            log('subtitles not found!')
        log('-- loadsubtitles stop --')
        pdialog.close()
        return success
    return False


@plugin.action('library')
def library(params):
    if params.mod == 'save':
        magneturi = checkMagnet(params.magnet)
        if not magneturi:
           return
        import ast
        item = ast.literal_eval(params.item)
        info = item['info']['video']
        name = info['originaltitle'] + " ("+params.year+")"
        name = name.replace("/", " ").replace("\\", " ").replace("?", "").replace(":", "").replace('"', "").replace('*', "").replace('|', "")
        path = plugin.get_setting("library_path", True)

        if info.get('mediatype', 'movie') == "movie":
            path = os.path.join(xbmc.translatePath(path), 'videos', name)
            if not os.path.exists(path):
                os.makedirs(path)
            uri = plugin.get_url(action="play_now", magnet=magneturi, selFile=0)
            fl = open(os.path.join(path, name+".strm"), "w")
            fl.write(uri)
            fl.close()
            notify(path)
        elif info.get('mediatype', 'movie') == "tvshow":
            path = os.path.join(xbmc.translatePath(path), 'tvshows', name)
            if not os.path.exists(path):
                os.makedirs(path)
            numEp = 1
            if 'All' in params.numEp:
                numEp = int(info.get('episode', 1))
            elif 'Multi' in params.numEp:
                notify("Multi seasons not saved", time=10000)
                return
            else:
                numEp = int(params.numEp)
            for ep in range(numEp):
                epname = name + " S{0}E{1:02d}".format(params.season, ep+1)
                uri = plugin.get_url(action="play_now", magnet=magneturi, selFile=ep)
                fl = open(os.path.join(path, epname+".strm"), "w")
                fl.write(uri)
                fl.close()
        xbmc.executebuiltin('UpdateLibrary("video")')

@plugin.action('tam')
def tam(params):
    import torrserve.totam as totam
    if params.magnet:
         url = checkMagnet(params.magnet)
    else:
         url = 'magnet:?xt=urn:btih:{0}&dn={1}'.format(str(params.hash).upper(), quote_plus(params.name))
    totam.opentam(url)

def run():
    plugin.run()
