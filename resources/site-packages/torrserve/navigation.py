# -*- coding: utf-8 -*-
import json
import time
import urllib
import re
import hashlib
import bencode
import os
import sys

import xbmc
import xbmcgui
import xbmcplugin
import xbmcvfs
import xbmcaddon

from client import client, touch, http_request
from config import TORRSERVED_HOST, ADDON_PATH
from simpleplugin import Params, Plugin
from utils import humanizeSize, notify, settingsIsOpen, parseName, checkMime, makeMovieItem, makeTvShowItem, get_label
from tmdb.api import TMDB
from xplayer import xPlayer
import searcher

plugin = Plugin()
translate = plugin.initialize_gettext()
tmdb = TMDB()

def addon_img_path(filename):
    return os.path.join(ADDON_PATH, "resources", "img", filename)


def getVerTS():
    engine = client()
    if engine.is_v2:
        return 2
    else:
        return 1

@plugin.action()
def root():
    resp = client().echo()
    if not resp:
        notify(translate("Server {0} is down").format(TORRSERVED_HOST))
        listing = get_listing("noindex")
        return Plugin.create_listing(listing, category="N/A")
    else:
        listing = get_listing("index")
        return Plugin.create_listing(listing, category="v"+str(resp), content='videos')

def get_listing(params, type=None):
    listing = []
    if params == "index":
        listing.append({
            'label': translate("Torrents List"),
            'url': plugin.get_url(action='torrents', mod='list'),
            'icon': addon_img_path("list.png"),
            'is_folder': True
        })
        if plugin.get_setting("use_torlook", True):
          listing.append({
            'label': translate("Search"),
            'url': plugin.get_url(action="search", mod="index"),
            'icon': addon_img_path("search.png"),
            'is_folder': True
          })
        listing.append({
            'label': translate('Open .torrent'),
            'url': plugin.get_url(action='file', mod='open'),
            'icon': addon_img_path("add.png"),
            'is_folder': True,
        })
        listing.append({
            'label': translate('Open all .torrent in dir'),
            'url': plugin.get_url(action='file', mod='opendir'),
            'icon': addon_img_path("add.png"),
            'is_folder': True,
        })
        listing.append({
            'label': translate("Settings"),
            'icon': addon_img_path("settings.png"),
            'url': plugin.get_url(action='settings', mod='read'),
            'is_folder': False,
        })
    elif params == "noindex":
        listing.append({
            'label': translate("Settings"),
            'icon': addon_img_path("settings.png"),
            'url': plugin.get_url(action='settings', mod='open'),
            'is_folder': False
        })
    elif params == "search":
        langD = (('ru', 'russians'), ('en', 'english speaking'), ('fr', 'french'),
               ('de', 'german'), ('it', 'italian'), ('ja', 'japanese'),
               )
        year = time.strftime('%Y') #"2020"
        if type == "movie":
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("Movies"), translate("Cartoons"), translate("per day")),
                'url': plugin.get_url(action='search', mod='trending', type='movie', wtime='day', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("Movies"), translate("Cartoons"), translate("per week")),
                'url': plugin.get_url(action='search', mod='trending', type='movie', wtime='week', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Movies")),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Cartoons")),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Movies"), year),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Cartoons"), year),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            for l, m in langD:
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Movies"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, lang=l, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Cartoons"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, lang=l, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
            listing.append({
                "label": translate("New Search"),
                'url': plugin.get_url(action='search', mod="search", type="movie"),
                'icon': addon_img_path("search.png"),
                "is_playable": False,
                'is_folder': True,
            })
        elif type == "tvshow":
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("TV Shows"), translate("Animated series"), translate("per day")),
                'url': plugin.get_url(action='search', mod='trending', type='tvshow', wtime='day', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("TV Shows"), translate("Animated series"), translate("per week")),
                'url': plugin.get_url(action='search', mod='trending', type='tvshow', wtime='week', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("TV Shows")),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Animated series")),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("TV Shows"), year),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Animated series"), year),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            for l, m in langD:
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("TV Shows"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, lang=l, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Animated series"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, lang=l, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
            listing.append({
                "label": translate("New Search"),
                'url': plugin.get_url(action='search', mod="search", type="tvshow"),
                'icon': addon_img_path("search.png"),
                "is_playable": False,
                'is_folder': True,
            })
        else:
            listing.append({
                "label": translate("Movies"),
                'url': plugin.get_url(action='search', mod="index", type="movie"),
                'icon': addon_img_path("movies.png"),
                "is_playable": False,
                'is_folder': True,
            })
            listing.append({
                "label": translate("TV Shows"),
                'url': plugin.get_url(action='search', mod="index", type="tvshow"),
                'icon': addon_img_path("tv.png"),
                "is_playable": False,
                'is_folder': True,
            })
            listing.append({
                'label': translate("Torrents"),
                'url': plugin.get_url(action='search', mod="torrent"),
                'icon': addon_img_path("search.png"),
                'is_playable': False,
                'is_folder': True,
            })
            type='video'
        with plugin.get_storage('historySearch'+type) as storage:
            i = 0
            while i < 10:
                try:
                    if storage['title{0}'.format(i)]:
                        listing.append({
                            'label': storage['title{0}'.format(i)],
                            'url': plugin.get_url(action='search', mod="search", type=type, query=storage['title{0}'.format(i)]) if type != 'video' else plugin.get_url(action='search', mod="torrent", type=type, query=storage['title{0}'.format(i)]),
                            'icon': addon_img_path("search.png"),
                            'is_playable': False,
                            'is_folder': True,
                            "context_menu": [(
                                translate("Remove query"),
                                "RunPlugin(%s)" % plugin.get_url(action="search", mod="history", type=type, delete='title{0}'.format(i)),
                            )]
                        })
                except:
                    pass
                finally:
                    i += 1
    return listing

@plugin.action('file')
def open_file(params):
    dialog = xbmcgui.Dialog()
    if params.link and params.link.startswith('http'):
        import requests
        r = requests.get(params.link)
        if r.ok:
            data = r.content
            if not data:
                return
            pFile = 'special://temp/torrserve.torrent'
            tFile = xbmc.translatePath(pFile)
            rtFile = tFile.decode('utf8')
            file(rtFile, 'wb').write(data)
        else:
            return
    else:
        tFile = dialog.browseSingle(1, translate('Select torrent file'), 'files', '.torrent')
        #dialog.ok('test', tFile)
    if tFile != '':
        listing = []
        tfiles = [tFile]
        if params.mod == 'opendir':
            dir = tFile[:tFile.rfind('/')]
            dirs, files = xbmcvfs.listdir(dir)
            files.sort()
            #dialog.ok('test', unicode(files))
            tfiles = [os.path.join(dir, i) for i in files if '.torrent' in i.lower()]
        for tfile in tfiles:
            tf = xbmcvfs.File(tfile)
            i = tf.read()
            tf.close()
            metainfo = bencode.bdecode(i)
            infohash = hashlib.sha1(bencode.bencode(metainfo['info'])).hexdigest()
            tr = [metainfo['announce']]
            if 'announce-list' in metainfo:
                for t in metainfo['announce-list']:
                    if t: 
                        tr.append(t.pop())
            params = {
                'dn': metainfo['info']['name'],
                'tr': tr,
            }
            magneturi = 'magnet:?xt=urn:btih:{0}&{1}'.format(str(infohash).upper(), urllib.urlencode(params, True))
            listing.append({
                'label': metainfo['info']['name'],
                'url': plugin.get_url(action='gotInfo', magnet=magneturi),
                'icon': addon_img_path("magnet.png"),
                'is_folder': True,
                "context_menu": [(
                    translate("Add to DB"),
                    "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magneturi),
                )]
            })
        return Plugin.create_listing(listing, cache_to_disk=True, category=tFile)

def pNone(p):
    return p if p !='None' else None

@plugin.action("search")
def search(params):
    poster = None
    listing = []
    if params.mod == "index":
        return Plugin.create_listing(get_listing("search", params.type))
    elif params.mod == "history":
        with plugin.get_storage('historySearch'+params.type) as storage:
            storage[params.delete] = None
        xbmc.executebuiltin("Container.Refresh")
        return
    elif params.mod in ("discover","trending"):
        result = {}
        page = params.page
        query = pNone(params.year)
        lang = pNone(params.lang)
        genres = pNone(params.genres)
        ngenres = pNone(params.ngenres)
        nextPage = int(page) + 1
        if params.type == "movie":
            if params.mod == "discover":
               result = tmdb.discover_movie(query, page, lang, genres, ngenres)
            else:
               result = tmdb.trending(mtype="movie", wtime=params.wtime, page=page)
            movie_ids = result['results']
            for movie in movie_ids:
                item = makeMovieItem(movie)
                item.update({'url': plugin.get_url(action='search', mod="torrent", query=movie['original_title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id']),
                'context_menu': [( translate('Search title and year'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id'], title='true') ),
                    ( translate('Search title'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id'], title='onlyname'),
                    )],
                })
                listing.append(item)
        elif params.type == "tvshow":
            if params.mod == "discover":
               result = tmdb.discover_tvshow(query, page, lang, genres, ngenres)
            else:
               result = tmdb.trending(mtype="tv", wtime=params.wtime, page=page)
            shows_ids = result['results']
            for show in shows_ids:
                item = makeTvShowItem(show)
                item.update({'url': plugin.get_url(action='search', mod="torrent", query=show['original_name'].encode('utf-8'), type="tvshow", id=show['id']),
                'context_menu': [( translate('Search title'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=show['name'].encode('utf-8'), type="tvshow", id=show['id'], title='true'),
                    )],
                })
                listing.append(item)
        maxPage = int(result.get('total_pages', '1'))
        if nextPage <= maxPage:
           listing.append({
              'label': "{0} / ({1})".format(translate("Next page ({0})").format(nextPage), maxPage),
              'icon': addon_img_path("nextpage.png"),
              'url': plugin.get_url(action='search', mod='discover', type=params.type, page=nextPage, year=query, lang=lang, genres=genres, ngenres=ngenres)
           })
        return Plugin.create_listing(listing, category="{0}: {1}".format(translate("Discover"), query), cache_to_disk=True, content="{0}s".format(params.type), view_mode=plugin.get_setting('search_view'))
    elif params.mod == "search":
        result = {}
        query = params.query
        dialog = xbmcgui.Dialog()
        if not query:
            query = dialog.input("Yohoho", type=xbmcgui.INPUT_ALPHANUM)
            if query == "":
                return
            with plugin.get_storage('historySearch'+params.type) as storage:
                storage['title9'] = storage.get('title8')
                storage['title8'] = storage.get('title7')
                storage['title7'] = storage.get('title6')
                storage['title6'] = storage.get('title5')
                storage['title5'] = storage.get('title4')
                storage['title4'] = storage.get('title3')
                storage['title3'] = storage.get('title2')
                storage['title2'] = storage.get('title1')
                storage['title1'] = storage.get('title0')
                storage['title0'] = query
        if params.type == "movie":
            result = tmdb.search_movies(query, params.page)
        else:
            result = tmdb.search_tv_shows(query, params.page)
        maxPage = int(result['total_pages'])
        nextPage = int(result['page'])+1
        movie_ids = result['results']
        for movie in movie_ids:
            if params.type == "movie":
                item = makeMovieItem(movie)
                item.update({'url': plugin.get_url(action='search', mod="torrent", query=movie['original_title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id']),
                'context_menu': [( translate('Search title and year'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id'], title='true') ),
                    ( translate('Search title'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['title'].encode('utf-8')+" "+str(movie['release_date'][:4]), type="movie", id=movie['id'], title='onlyname'),
                    )],
                })
                listing.append(item)
            elif params.type == "tvshow":
                if movie['number_of_seasons'] > 0:
                    item = makeTvShowItem(movie)
                    item.update({
                        'url': plugin.get_url(action='search', mod="torrent", query=movie['original_name'].encode('utf-8'), type="tvshow", id=movie['id']),
                        'context_menu': [( translate('Search title'),
                            'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['name'].encode('utf-8'), type="tvshow", id=movie['id'], title='true'),
                            )],
                    })
                    listing.append(item)
        if nextPage <= maxPage:
           listing.append({
             'label': "{0} / ({1})".format(translate("Next page ({0})").format(nextPage), maxPage),
             'icon': addon_img_path("nextpage.png"),
             'url': plugin.get_url(action='search', mod='search', type=params.type, query=query, page=nextPage)
           })
        return Plugin.create_listing(listing, category="{0}: {1}".format(translate("Search"), query), cache_to_disk=True, content="{0}s".format(params.type), view_mode=plugin.get_setting('search_view'))
    elif params.mod == "torrent":
        selSeason = params.selSeason
        ext_info = ""
        query = params.query
        if query is None:
            params.type = "video"
            dialog = xbmcgui.Dialog()
            query = dialog.input(translate("Torrents"), type=xbmcgui.INPUT_ALPHANUM)
            if query == "":
                return False
            with plugin.get_storage('historySearch'+params.type) as storage:
                storage['title9'] = storage.get('title8')
                storage['title8'] = storage.get('title7')
                storage['title7'] = storage.get('title6')
                storage['title6'] = storage.get('title5')
                storage['title5'] = storage.get('title4')
                storage['title4'] = storage.get('title3')
                storage['title3'] = storage.get('title2')
                storage['title2'] = storage.get('title1')
                storage['title1'] = storage.get('title0')
                storage['title0'] = query
        else:
            query = query.decode('utf-8')
        if params.type == "tvshow" and params.title:
            ext_info = tmdb.get_tv_show(params.id)
            selSeason = ""
            query = ext_info['name'].encode('utf-8')
        elif params.type == "tvshow" and selSeason is None:
            ext_info = tmdb.get_tv_show(params.id)
            listing = []
            for number in range(1, ext_info['number_of_seasons']+1, 1):
                item = makeTvShowItem(ext_info, "season", number)
                item.update({
                    'url': plugin.get_url(action='search', mod=params.mod, type=params.type, id=params.id, query=params.query, selSeason=number)
                })
                listing.append(item)
            return Plugin.create_listing(listing, cache_to_disk=True, sort_methods=xbmcplugin.SORT_METHOD_LABEL, content="{0}s".format(params.type))
        elif params.type == "tvshow" and selSeason:
            ext_info = tmdb.get_tv_show(params.id)
            selSeason = "{0:02d}".format(int(selSeason))
            query = ext_info['original_name'].encode('utf-8')
        elif params.type == "movie":
            ext_info = tmdb.get_movie(params.id)
            if params.title:
                  query = "{0}".format(ext_info['title'].encode('utf-8'))
            else:
                  query = "{0}".format(ext_info['original_title'].encode('utf-8'))
            if params.title == "onlyname":
                  pass
            else:
                  query = query + " ({0})".format(ext_info['release_date'][:4])
#        if (plugin.get_setting("use_torlook", True)):
        if True:
#            torlook_query = query.replace(" ", "%20")
#            result = client("/{0}/size".format(torlook_query), host='https://torlook.info')
            if isinstance(query, unicode): query = query.encode('utf8')
            result = searcher.Query(query)
            if not result:
                notify(translate("Empty result")+" "+query)
                return False
#            match = re.finditer(r'<p><a rel="nofollow".+?>(.+?)</a></p>.+?blank">(.+?)</a>.+?<span class="size">(.+?)</span>.+?href="(.+?)"', result, re.DOTALL)
#        else:
#            yohoho_query = query.replace(" ", "%20").replace("-", "+")
#            result = client("/4h0y", get_data={'title': yohoho_query}, post_data={}, host='https://ahoy.yohoho.cc')
#            if not result:
#                notify(translate("Empty result")+" "+query)
#                return False
#            match = re.finditer(r"href =.+?'(magnet:\?.+?)';\">(.+?)<\/span>.+?<div>(.+?)<\/div>", result, re.DOTALL)
#        for t in match:
        for t in result:
            magnet    = t['url']
            name      = t['title']
            trackers  = "rutor,torlook"
            stringSize= t['size']
            seeds = t['sids']
#            if(plugin.get_setting("use_torlook", True)):
#                magnet = t.group(4)
#                name = t.group(1)
#                trackers = t.group(2)
#            else:
#                magnet = t.group(1)
#                name = t.group(2)
#                trackers = "yohoho"
            name = name.replace("<b>", "").replace("</b>", "")

#            if trackers not in ["kinozal.tv", "yohoho", "rutor.info", "nnmclub.to", "rutracker.org", "torrent.by", "underverse.su", "toloka.to"]:
#                continue
            item = dict()
            size = ""
#            stringSize = t.group(3).replace('&nbsp;', ' ')
            if not isinstance(stringSize, basestring):
                size = long(stringSize)
                stringSize = humanizeSize(stringSize).encode('utf8')
            elif stringSize[stringSize.rfind(' ')+1:] in ['МБ', 'MB']:
                size = long(float(stringSize[:stringSize.rfind(' ')]) * float(2 << 19))
            else:
                size = long(float(stringSize[:stringSize.rfind(' ')]) * float(2 << 29))
            context_menu = [(
                translate("Add to DB"),
                "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magnet),
            )]
            if params.type == 'movie':
                if name.find(query) == -1 and not (name.find(query.split('(')[0])>-1 and (name.find(query.replace('(','([').split('(')[1].strip(' )'))>-1 or name.find(query.replace('(','((').split('(', 1)[1].strip())>-1 or name.find(query.replace('(','(/ ').split('(', 1)[1].strip().replace(')',' /'))>-1)):
                    continue
                item = makeMovieItem(ext_info, False, size)
		poster = item['art'].get('poster')
                context_menu = [(
                    translate("Add to DB"),
                    "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magnet, info=json.dumps({'kodi':{'info': item['info']['video'], 'cast':item['cast']}, 'poster_path':item['art']['poster'] }) ),
                )]
                context_menu.append((
                    translate('Save to Library'),
                    'RunPlugin({0})'.format(plugin.get_url(action='library', mod='save', id=ext_info['id'], year=ext_info['release_date'][:4], magnet=magnet, item=repr(item)))
                ))
            elif params.type == 'tvshow':
                numEp = ""
                numSeason = selSeason[1:] if selSeason and selSeason.startswith('0') else selSeason
                if query in name and name.find('S'+selSeason) > -1:
                    if '[S'+selSeason+']' in name:
                        numEp = "All"
                    elif '[S01-' in name:
                        numEp = "Multi"
                    else:
                        numEp = name[name.find('S'+selSeason)+4:name.find('S'+selSeason)+6]
                elif query in name and name.find(selSeason+'x') > -1:
                    numEp = name[name.find(selSeason+'x')+6:name.find(selSeason+'x')+8]
                    if 'и' in numEp:
                        numEp = name[name.find(selSeason+'x')+3:name.find(selSeason+'x')+5]
                elif query in name and name.find('['+selSeason+'-') > -1:
                    numEp = name[name.find('['+selSeason+'-')+4:name.find('['+selSeason+'-')+6]
                elif query in name and name.find('Сезон: '+numSeason) > -1:
                    fk = 'Сезон: '+numSeason
                    sk = name.find(fk)
                    if name[sk+len(fk):sk+len(fk)+1].isdigit(): continue
                    numEp = 'Multi' #TODO
                elif query in name and (name.find(numSeason+' сезон') > -1 or name.find('сезон '+numSeason) > -1):
                    fk = 'сезон '+numSeason
                    sk = name.find(fk)
                    if sk > -1 and name[sk+len(fk):sk+len(fk)+1].isdigit(): continue
                    numEp = 'Multi'
                else: continue
                if params.selSeason:
                     item = makeTvShowItem(ext_info, "season", int(params.selSeason), True, size)
                else:
                     item = makeTvShowItem(ext_info, "tvshow", None, True, size)
		poster = item['art'].get('poster')
                context_menu = [(
                    translate("Add to DB"),
                    "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magnet, info=json.dumps({'kodi':{'info': item['info']['video'], 'cast':item['cast']}, 'poster_path':item['art']['poster'] }) ),
                )]
                context_menu.append((
                    translate('Save to Library'),
                    'RunPlugin({0})'.format(plugin.get_url(action='library', mod='save', id=ext_info['id'], year=ext_info['first_air_date'][:4], magnet=magnet, season=selSeason, numEp=numEp, item=repr(item)))
                ))
            label = get_label(name)
            name = "[B]{1}[COLOR=FFFFFFFF]/{0}/[/COLOR][/B][COLOR=FFFFFFFF]{3}/[/COLOR] {2}".format(stringSize.replace(' ', ''), label, name, seeds)
            stream_info = ""
            if '2160' in label:
                stream_info = {'video': {'width': 3840, 'height': 2160}}
            elif '1080' in label:
                stream_info = {'video': {'width': 1920, 'height': 1080}}
            elif '720' in label:
                stream_info = {'video': {'width': 1280, 'height': 720}}
            else:
                stream_info = ""
            context_menu.append((
                translate('Open TAM'),
                'RunPlugin({0})'.format(plugin.get_url(action='tam', magnet=magnet)),
            ))
            item.update({
                "label": name,
                'url': plugin.get_url(action='gotInfo', magnet=magnet, poster=poster) if poster else plugin.get_url(action='gotInfo', magnet=magnet),
                'is_folder': True,
                "context_menu": context_menu,
                'stream_info': stream_info
            })
            listing.append(item)
        view_mode = plugin.get_setting('result_view')
        if params.usearch == 'True': view_mode = '0'
        return Plugin.create_listing(listing, category="{0}".format(translate("Search")), cache_to_disk=True, sort_methods=(xbmcplugin.SORT_METHOD_LABEL, xbmcplugin.SORT_METHOD_SIZE), content="{0}s".format(params.type), view_mode=view_mode)
    return False

@plugin.action('descript')
def descript(params):
	gui = GuiTextViewer('DialogTextViewer.xml', sys.argv[0], descript=params.text, title=translate("Description"))
	gui.doModal()
	del gui
	return True


class GuiTextViewer(xbmcgui.WindowXMLDialog):
    def __init__(self, *args, **kwargs):
        self.descript = kwargs['descript']
        self.title = kwargs['title']
        xbmcgui.WindowXMLDialog.__init__(self, *args, **kwargs)
    
    def onInit(self):
        #lang = Lang()
        self.getControl(1).setLabel(self.title)
        self.getControl(5).setText(self.descript)
    
    def onFocus(self, control):
        pass


def checkMagnet(magneturi):
    kinozalurl = plugin.get_setting("kinozal_url")
    if not magneturi:
            pass
    elif '://torlook.info/dl/' in magneturi:
            html = http_request('', host=magneturi, ljs=False)
            r = re.compile(r"(magnet:.+?)'>").search(html)
            if not r:
                return
            magneturi = r.group(1)
    elif '://kinozal-tv.appspot.com/magnet?' in magneturi or (kinozalurl.strip() !="" and '://'+kinozalurl.strip()+'/magnet?' in magneturi):
            from searcher.scrapers.kinozal import get_magnet as kz_magnet
            magneturi = kz_magnet(magneturi.split('magnet?')[1])
    elif magneturi.startswith('http'):
            data = http_request('', host=magneturi, ljs=False)
            if not data:
               return
            try:
               metainfo = bencode.bdecode(data)
            except BaseException as e:
               if data.find('keywords" content="nnm-club,') != -1:
#                  file('/home/osmc/tserror.txt', 'wb').write(data.decode('cp1251').encode('utf8'))
                  r = re.compile(r'name="redirect"\s+value="([^"]+)"').search(data)
                  if not r:
                     return
                  redirect = r.group(1)
                  from searcher.scrapers.nnmclub import Tracker
                  login = plugin.get_setting("nnmclub_login")
                  password = plugin.get_setting("nnmclub_password")
                  if login == "" or password == "":
                      notify("Нужен логин и пароль NNMClub для просмотра раздачи")
                      return
                  data2 = Tracker().Login(login, password, redirect)
                  if data2.find('keywords" content="nnm-club,') != -1:
                      notify("Неверный логин и пароль от NNMClub")
                      return
#                  try:
                  metainfo = bencode.bdecode(data2)
#                  except BaseException as e:
#                      notify(str(e))
               else:
                  notify(str(e))
            infohash = hashlib.sha1(bencode.bencode(metainfo['info'])).hexdigest()
            tr = [metainfo['announce']]
            if 'announce-list' in metainfo:
                for t in metainfo['announce-list']:
                    if t: tr.append(t.pop())
            mparams = {
            'dn': metainfo['info']['name'],
            'tr': tr,
            }
            magneturi = 'magnet:?xt=urn:btih:{0}&{1}'.format(str(infohash).upper(), urllib.urlencode(mparams, True))
    return magneturi

def makeTorrentsList():
    #request = int(plugin.get_setting("without_info", True))
    #response = client("/torrent/shortlist", post_data={"Request": request, "Info": 1})
    #if response is None: 
    response = client().list()  #("/torrent/list", post_data={"Request": request})
    for torrent_item in response:
        engine = client(hash=torrent_item['Hash'])

        title = engine.title
        label = parseName( title if title else torrent_item['Name']) 
        size = torrent_item.get('Length')
        if size:
            size = humanizeSize(size)
        item = {
            "label": u"[{0}] {1}".format(size, label) if size else label,
            "url": plugin.get_url(action="torrents", mod="files", hash=torrent_item['Hash']),
            "icon": addon_img_path("magnet.png"),
            "context_menu": [(  
                translate("Delete from DB"),
                "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="delete", hash=torrent_item["Hash"]),
            ), (
                translate("Open TAM"),
                "RunPlugin(%s)" % plugin.get_url(action="tam", hash=torrent_item["Hash"], name=label.encode('utf8', 'replace')),
            )],
        }

        art = engine.get_art()
        if art:
            xbmc.log('Has art')
            xbmc.log(unicode(art))
            item.update({'art': art})
            if 'thumb' in art:
                item['icon'] = art['thumb']

        video_info = engine.get_video_info()
        if video_info:
            xbmc.log('Has video info')
            xbmc.log(unicode(video_info))
            if 'info' in item and item['info'].get('video'): 
                video_info['mediatype'] = "movie"
            item['info'] = { 'video': video_info }

        if 'Info' in torrent_item and torrent_item['Info'] != "{}":
            i = json.loads(torrent_item['Info'])
            if 'descript' in i:
                item['context_menu'].insert(0,(
                    translate("Description"),
                    "RunPlugin(%s)" % plugin.get_url(action="descript", text=i['descript'].encode('utf8', 'replace')),
                ))

            if 'kodi' in i:
                if 'info' in i['kodi'] and i['kodi'].get('info'):
                    item['info'] = { 'video': i['kodi']['info'] }
                if 'cast' in i['kodi'] and i['kodi'].get('cast'):
                    item['cast'] = i['kodi']['cast']
        yield item

def makeFileList(hash):
    onlymedia = plugin.get_setting("only_media", True)
    engine = client(hash=hash)
    engine._wait_for_data()

    files = engine.files()

    for f in files:
        xbmc.log(unicode(f))

        if onlymedia and checkMime(f['path']) == "*/*":
            continue

        video_info = engine.get_video_info()

        item = {
            "label": parseName(f['path'].split('/')[-1]),
            "url": plugin.get_url(action="play", sort_index=f['file_id'], name=f['path'], hash=hash),
            "is_playable": True,
            "info": {"video": video_info}
        }
        art = engine.get_art()
        if art:
            item.update({'art': art})

        yield item

@plugin.action("torrents")
def torrents(params):
    listing = []
    view_mode = '0'
    if params.mod == "list":
        listing = makeTorrentsList()
    elif params.mod == "files":
        listing = makeFileList(params.hash)
        view_mode = plugin.get_setting('files_view')
    elif params.mod == "add":
        magneturi = checkMagnet(params.magnet)
        client.add(magneturi, params.info.get('title'), params.info.get('poster'))
        notify(translate("Saved!"))
        return
    elif params.mod == "delete":
        client.rem(params.hash)
        notify(translate("Deleted!"))
        xbmc.executebuiltin("Container.Refresh")
        return
    return Plugin.create_listing(listing, content="videos", category="Torrents", view_mode=view_mode)

@plugin.action()
def settings(params):
    plugin.addon.openSettings()
    '''
    if params.mod == "read":
        if getVerTS() != 1:
            plugin.addon.openSettings()
            return
        resp = client("/settings/read", post_data={"read": 1})
        for k, v in resp.items():
            if k == "CacheSize" or k == "PreloadBufferSize":
                v = (v / 1024) / 1024
            plugin.set_setting(k, str(v).lower())
        plugin.addon.openSettings()
        while settingsIsOpen():
            continue

        jset = {
            "CacheSize": plugin.get_setting("CacheSize", True) * 1024 * 1024,
            "PreloadBufferSize": plugin.get_setting("PreloadBufferSize", True) * 1024 * 1024,
            "RetrackersMode": plugin.get_setting("RetrackersMode", True),
            "DisableTCP": plugin.get_setting("DisableTCP", True),
            "DisableUTP": plugin.get_setting("DisableUTP", True),
            "DisableUPNP": plugin.get_setting("DisableUPNP", True),
            "DisableDHT": plugin.get_setting("DisableDHT", True),
            "DisableUpload": plugin.get_setting("DisableUpload", True),
            "Encryption": plugin.get_setting("Encryption", True),
            "DownloadRateLimit": plugin.get_setting("DownloadRateLimit", True),
            "UploadRateLimit": plugin.get_setting("UploadRateLimit", True),
            "ConnectionsLimit": plugin.get_setting("ConnectionsLimit", True),
            "PeersListenPort": plugin.get_setting("PeersListenPort", True)
        }
        for i in ("EnableIPv6","DhtConnectionLimit","TorrentDisconnectTimeout","M3UContentType","SupportMode",
                  "DisableRealId","RequestStrategy","BuiltinRetrackers","NewtrackonRetrackers","MigrateDB",
                  "NgosangallipRetrackers","MaxRunTorrents","DelMaxRunTorrent","RemoveViewed","RemoveInfo",
                  "DisableCtrlViewed"):
               if i in resp: jset[i] = plugin.get_setting(i, True)
        if not resp == jset:
            resp = client("/settings/write", post_data=jset)
            if resp == "Ok":
                notify(translate("Settings saved! Restart service"))
                client.restart()
                xbmc.executebuiltin("Container.Refresh")
            else:
                notify(translate("Settings not saved!"))
                plugin.log_error(repr(resp))
    elif params.mod == "open":
        plugin.addon.openSettings()
    '''

def getHash(mag):
    if mag.startswith("magnet%"):
         mag = urllib.unquote_plus(mag)
    return mag[20:60]

def prebuffer(engine):
    pDialog = xbmcgui.DialogProgress()
    #pDialog.create("TorrServer", "Wait for info....")
    pDialog.create("TorrServer", 
            translate("Wait for info..."), 
            translate("Connected: {0} | Active: {1} | Total: {2}").format(0, 0, 0))

    success = False
    counter = 0
    while True:
        #if counter > 60:
        #    return False

        if pDialog.iscanceled() :
            pDialog.close()
            engine.drop()
            break

        time.sleep(0.5)
        try:
            st = engine.stat()
            xbmc.log(unicode(st))
        except BaseException as e:
            xbmc.log('continue...')
            xbmc.log(unicode(e))
            continue
        #_log(st)

        if 'message' in st:
            counter += 1
            continue

        downSpeed = humanizeSize(st.get('DownloadSpeed', 0))
        preloadedBytes = st.get('PreloadedBytes', 0)
        preloadSize = st.get('PreloadSize', 0)
        line2 = translate("Connected: {0} | Active: {1} | Total: {2}").format(
            st.get('ConnectedSeeders', 0),
            st.get('ActivePeers', 0),
            st.get('TotalPeers', 0))

        line3 = u"D: {0}/{3} [{1}/{2}]".format(
            downSpeed, 
            humanizeSize(preloadedBytes), 
            humanizeSize(preloadSize),
            's'
        )

        if preloadSize > 0 and preloadedBytes > 0:
            prc = preloadedBytes * 100 / preloadSize
            if prc > 100:
                prc = 100
            pDialog.update(prc, line2, line3)

            stat_s = st.get('TorrentStatusString')

            stat_id = st.get('TorrentStatus')
            if  (preloadedBytes >= preloadSize) or \
                (prc > 0 and stat_id != 2): # 2 - 'Torrent preload'
                success = True
                pDialog.close()
                break

    return success

@plugin.action("play")
def play(params):
    _play(params.hash, int(params.sort_index))

def _play(hash, sort_index):
    def log(s):
        xbmc.log(s)
    log(hash)
    engine = client(hash=hash, log=log)
    engine.start(sort_index)
    #subtitles = loadsubtitles(hash, params.link),    
    #success, index = makePreloadDialog(hash, sort_index)engine.start(sort_index)
    success = prebuffer(engine)
    if success:
        player = xPlayer(hash=hash, index=sort_index)
        playable_url = engine.play_url(sort_index)
        label=engine.title
        video_info = engine.get_video_info()
        if 'title' in video_info:
            label = video_info['title']
        item = xbmcgui.ListItem(path=playable_url, label=label)
        item.setInfo('video', video_info)
        
        #if subtitles:    
        #    item.setSubtitles(subtitles)

        xbmcplugin.setResolvedUrl(int(sys.argv[1]), success, item)

        while not player.isPlaying() and not xbmc.abortRequested:
            xbmc.sleep(100)
        # Wait until playing finished or abort requested
        while player.isPlaying() and not xbmc.abortRequested:
            xbmc.sleep(500)

    engine.drop()
            

@plugin.action("play_now")
def play_now(params):
    hash = getHash(params.magnet)
    save_in_db = plugin.get_setting("save_in_db", True)
    sort_index = int(params.selFile)

    #subtitles = loadsubtitles(getHash(params.magnet), fileid = params.selFile)

    _play(hash, sort_index)

    if not save_in_db:
        engine = client(hash=hash)
        engine.rem()


@plugin.action("gotInfo")
def gotInfo(params):
    magneturi = checkMagnet(params.magnet)
    if not magneturi:
       return
    pDialog = xbmcgui.DialogProgress()
    pDialog.create("TorrServer", translate("Wait for info..."))
    listing = []
    success = False
    i = 0

    import datetime
    first_time = datetime.datetime.now()

    engine = client()
    engine.add(magneturi, poster=params.get('poster'))

    def make_item(file):
        item = {
            "label": file['path'].split('/')[-1],
            "url": plugin.get_url(action="play_now", 
                                    magnet=magneturi, 
                                    selFile=file['file_id']),
            "is_playable": True,
            "info": {"video": {
                'size': file['size'],
            }}
        }
        if params.poster:
            item.update({'art': {
                'thumb': params.poster,
                'poster': params.poster,
            }})
        return item

    while not pDialog.iscanceled():
        xbmc.sleep(500)
        stat = engine.stat()
        #if stat is None or len(stat['FileStats']) == 0:
        if stat['TorrentStatusString'] != 'Torrent working':
            xbmc.sleep(500)
            now_time = datetime.datetime.now()
            difference = now_time - first_time
            mins, secs = divmod(difference.seconds, 60)
            procents = difference.seconds * 2
            if difference.seconds > 100:
                pDialog.update(procents, 'Информация о [B]{2}[/B] не получена за {0:02d} : {1:02d} с.'.format(
                                                mins, 
                                                secs, 
                                                stat.get('Name', 'раздаче')), 
                                    'Видимо это мертвая раздача и отсутствуют пиры.')
            else:
                pDialog.update(procents, 'Пытаемся подключиться к раздаче [B]{0:02d} : {1:02d}[/B] с.'.format(
                                                mins, secs))
            continue
        else:
            files = engine.files()
            for file in files:
                if file['path'].find('/BDMV/') > 0:
                    if int(file['size']) > 1073741824 or file['path'].find('/BDMV/index.bdmv') > 0:
                        listing.append(make_item(file))
                elif checkMime(file['path']) in ("video/*", "audio/*"):
                    listing.append(make_item(file))
            success = len(listing) > 0
            pDialog.close()
            break

    if success:
        return Plugin.create_listing(listing, content="videos", category="Файлы", succeeded=success)
    else:
        return Plugin.create_listing(listing, succeeded=success)

def cleanname(s):
    for i in (' ','%','!','*',"'",'(',')',';',':','@','&','=','+','$',',','/','?','#','[',']','~','"','{','}'):
         s = s.replace(i,'_')
    s = s.replace('__','_')
    if isinstance(s, unicode): s = s.encode('utf8')
    return s


def loadsubtitles(hash=None, link=None, fileid=None):
    if hash and (link or fileid) and plugin.get_setting('use_subtitles', True):
        xbmc.log('-- loadsubtitles start --')
        success = False
        global self_prev_name, self_rus
        self_prev_name = ''
        self_rus = ''

        def cfname(name, rus=''):
            global self_prev_name, self_rus
            if '/' in name: name = name.split('/')[-1]
            if (name == self_prev_name) and (rus == self_rus): name = name[:name.rfind('.')] + u'_2_' + name[name.rfind('.'):]
            self_prev_name = name
            self_rus = rus
            if rus and (rus.lower() not in name.lower()): name = name[:name.rfind('.')] + rus + name[name.rfind('.'):]
            elif rus and (rus.lower() in name.lower()): name = name.replace(rus.lower(), rus).replace(rus.upper(), rus)
            return name

        if link:
            fname = link.split('/')[-1]
            if '/preload/' not in link: fname = fname.split('?')[0]
            fname = urllib.unquote_plus(fname)
            if isinstance(fname, unicode): fname = fname.encode('utf8')
        stat = {}
        counter = 0
        pdialog = xbmcgui.DialogProgress()
        pdialog.create('TorrServer', translate('Start find subtitles...'))
        while not stat.get('FileStats'):
            if pdialog.iscanceled():
                pdialog.close()
                return False
            prc = counter*100/120
            pdialog.update(prc, translate('Find subtitles...'))
            stat = client(hash=hash).stat()
            if stat is None:
                stat = {}
            if counter > 120:
                pdialog.close()
                return False
            counter += 1
            time.sleep(0.5)

        self_filestats = stat['FileStats']
        ind = 0
        self_index = ind
        findfullname = None
        for f in self_filestats:
            if fileid:
                if int(f['Id']) == int(fileid):
                    findfullname = f['Path']
                    self_index = ind
            elif link:
                if cleanname(f['Path']) == fname:
                    findfullname = f['Path']
                    self_index = ind
            ind += 1
            if not findfullname:
                pdialog.close()
                return False
        findname = findfullname
        if '/' in findname:
                findname = findname.split('/')[-1]
        findname = findname[:findname.rfind('.')]
        #		self_log(findname)
        index = 0
        temp_list = []
        for i in self_filestats:
            name = i['Path']
            if findname in name:
                if index != self_index:
                    if '.' in name:
                        ext = name.split('.')[-1]
                        if ext in ('srt', 'ass', 'ssa', 'smi'):
                            fileid = int(i['Id'])
                            temp_list.append( (index, fileid, name) )
            index += 1
        #		self_log(temp_list)
        xbmc.log('--sort subtitles--')
        if temp_list !=[]:
            temp_rus = []
            temp_eng = []
            temp_other = []
            del_list = []
            for f in range(len(temp_list)):
                i = temp_list[f]
                n = i[2].lower()
                if '/rus/' in n:
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    del_list.insert(0, f)
                elif '/eng/' in n:
                    temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                    del_list.insert(0, f)
            for i in del_list: del temp_list[i]
            for i in temp_list:
                n = i[2].lower()
                if ('.rus' in n) or ('_rus' in n) or ('_ru.' in n):
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                elif ('.eng' in n) or ('_eng' in n): temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                elif 'rus ' in n:
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                elif 'eng ' in n: temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                else: temp_other.append( (i[0], i[1], cfname(i[2]), i[2] ) )
            if temp_rus == [] and temp_other:
                i = temp_other[0]
                temp_rus.append( (i[0], i[1], cfname(i[3], '.Rus'), i[3] ) )
                del temp_other[0]
            temp_l = []
            temp_l.extend(temp_rus)
            temp_l.extend(temp_eng)
            temp_l.extend(temp_other)
#			self_log(temp_l)
            subtitles = []
            counter = 1
            for i in temp_l:
                uname = "/torrent/view/"+str(hash).lower()+"/"+urllib.quote_plus( cleanname(i[3]) )
#					self_log(uname)
                prc = counter*100/len(temp_l)
                pdialog.update(prc, translate('Load subtitles {0} / {1}').format(counter,len(temp_l)) )
                data = client(uname)
#					self_log(data)
                if data:
                    class Handler:
                        @staticmethod
                        def path(*path):
                            p = [xbmc.translatePath('special://temp').decode('utf8')]
                            p.extend(path)
#								print p
                            return os.path.join(*p)
                    sdir  = Handler().path('subtitles_torrserve')
                    if not os.path.isdir(sdir): os.mkdir(sdir)
                    fname = Handler().path('subtitles_torrserve', i[2])
                    with open(fname, 'wb') as file:
                        file.write(data)
                    subtitles.append(fname)
                else:
                    xbmc.log('error loading subtitles!')
                    success = False
                    break
            if subtitles !=[]: success = subtitles
        else:
            xbmc.log('subtitles not found!')
        xbmc.log('-- loadsubtitles stop --')
        pdialog.close()
        return success
    return False


def makePreloadDialog(hash, fileId=None, link=None):
    engine = client(hash=hash)
    resp = engine.echo()
    time.sleep(0.5)
    if not resp:
         resp = engine.echo()
         time.sleep(0.5)
    pDialog = xbmcgui.DialogProgress()
    pDialog.create("TorrServer", translate("Wait for info..."), translate("Connected: {0} | Active: {1} | Total: {2}").format(0, 0, 0))
    success = False
    onetouch = True
    ind = None
    counter = 0
    name = ""
    while not pDialog.iscanceled():
        if pDialog.iscanceled():
            pDialog.close()
            engine.drop()
            break
        time.sleep(0.5)
        stat = engine.stat()
        if onetouch and link and stat and stat.get('PreloadSize') == 0 and stat.get('TorrentStatus') == 3: # fix wait info
            touch("{0}{1}".format(TORRSERVED_HOST, link))
            onetouch = False
        if stat is None:
            counter += 1
            if counter < 60:
                time.sleep(0.5)
                continue
            else:
                notify("Time is over")
                pDialog.close()
                break
        else:
            if name == "":
                if (fileId or link) and ('FileStats' not in stat or not stat['FileStats']):
                    stat = {}
                    while not stat.get('FileStats') and not pDialog.iscanceled():
                         time.sleep(0.5)
                         stat = engine.stat()
                if fileId and stat['FileStats']:
                    itemp = 0
                    for f in stat['FileStats']:
                        if int(f['Id']) == int(fileId):
                            name = f['Path'][f['Path'].rfind('/')+1:]
                            ind = itemp
                        itemp += 1
                elif link and stat['FileStats']:
                    fname = link.split('/')[-1]
                    if '/preload/' not in link: 
                        fname = fname.split('?')[0]
                    fname = urllib.unquote_plus(fname)
                    if isinstance(fname, unicode): 
                        fname = fname.encode('utf8')
                    itemp = 0
                    for f in stat['FileStats']:
                        if cleanname(f['Path']) == fname:
                            name = f['Path'][f['Path'].rfind('/')+1:]
                            ind = itemp
                        itemp += 1
                else:
                    name = stat['Name']
            downSpeed = humanizeSize(stat.get('DownloadSpeed', 0))
            preloadedBytes = stat.get('PreloadedBytes', 0)
            preloadSize = stat.get('PreloadSize', 0)
            line2 = translate("Connected: {0} | Active: {1} | Total: {2}").format(
                    stat.get('ConnectedSeeders', 0),
                    stat.get('ActivePeers', 0),
                    stat.get('TotalPeers', 0))
            line3 = u"D: {0}/сек [{1}/{2}]".format(
                downSpeed, 
                humanizeSize(preloadedBytes), 
                humanizeSize(preloadSize))

            stat_id = stat.get('TorrentStatus')

            if preloadSize > 0 and preloadedBytes < preloadSize:
                prc = preloadedBytes * 100 / preloadSize
                if prc > 100:
                    prc = 100
                pDialog.update(prc, name, line2, line3)
            elif (preloadedBytes >= preloadSize) or \
                    (prc > 0 and stat_id != 2): # 2 - 'Torrent preload':
                if not pDialog.iscanceled(): 
                    success = True
                pDialog.close()
                break
    return success, ind

@plugin.action('library')
def library(params):
    if params.mod == 'save':
        magneturi = checkMagnet(params.magnet)
        if not magneturi:
           return
        import ast
        item = ast.literal_eval(params.item)
        info = item['info']['video']
        name = info['originaltitle'] + " ("+params.year+")"
        name = name.replace("/", " ").replace("\\", " ").replace("?", "").replace(":", "").replace('"', "").replace('*', "").replace('|', "")
        path = plugin.get_setting("library_path", True)

        if info.get('mediatype', 'movie') == "movie":
            path = os.path.join(xbmc.translatePath(path), 'videos', name)
            if not os.path.exists(path):
                os.makedirs(path)
            uri = plugin.get_url(action="play_now", magnet=magneturi, selFile=0)
            fl = open(os.path.join(path, name+".strm"), "w")
            fl.write(uri)
            fl.close()
            notify(path)
        elif info.get('mediatype', 'movie') == "tvshow":
            path = os.path.join(xbmc.translatePath(path), 'tvshows', name)
            if not os.path.exists(path):
                os.makedirs(path)
            numEp = 1
            if 'All' in params.numEp:
                numEp = int(info.get('episode', 1))
            elif 'Multi' in params.numEp:
                notify("Multi seasons not saved", time=10000)
                return False
            else:
                numEp = int(params.numEp)
            for ep in range(numEp):
                epname = name + " S{0}E{1:02d}".format(params.season, ep+1)
                uri = plugin.get_url(action="play_now", magnet=magneturi, selFile=ep)
                fl = open(os.path.join(path, epname+".strm"), "w")
                fl.write(uri)
                fl.close()
        xbmc.executebuiltin('UpdateLibrary("video")')
        return True

@plugin.action('tam')
def tam(params):
    import totam
    if params.magnet:
         url = checkMagnet(params.magnet)
    else:
         url = 'magnet:?xt=urn:btih:{0}&dn={1}'.format(str(params.hash).upper(), urllib.quote_plus(params.name))
    totam.opentam(url)

def run():
    plugin.run()
