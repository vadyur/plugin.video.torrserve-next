# -*- coding: utf-8 -*-
from __future__ import absolute_import

import json
import time
import urllib
import re
import hashlib

import os
import sys
from vdlib.kodi.player import OurDialogProgress
from vdlib.util import filesystem
from vdlib.util import quote_plus, unquote_plus
from vdlib.util.string import decode_string
from vdlib.kodi.compat import translatePath

import xbmc
import xbmcgui
import xbmcplugin
import xbmcaddon

from simpleplugin import Plugin
from torrserve.client import client, touch, http_request
from tmdb.api import TMDB
from torrserve.config import TORRSERVED_HOST, ADDON_PATH
from torrserve.utils import humanizeSize, notify, settingsIsOpen, parseName, checkMime, makeMovieItem, makeTvShowItem, get_label
from torrserve.xplayer import xPlayer

from torrserve.simpleplugin3_suport import create_listing

if sys.version_info >= (3, 0):
    from torrserve.py3 import bencode
    str_type = str
    from urllib.parse import urlencode
else:
    str_type = unicode
    from . import bencode
    from urllib import urlencode

plugin = Plugin()
try:
    translate = plugin.initialize_gettext() # type: ignore
except:
    def translate(s):
        return s
tmdb = TMDB()

def log(s):
    message = u'[{}: navigation.py]: {}'.format(plugin.id, s)
    xbmc.log(message)

def addon_img_path(filename):
    return os.path.join(ADDON_PATH, "resources", "img", filename)

def getVerTS():
    engine = client()
    if engine.is_v2:
        return 2
    else:
        return 1

def getViewMode(id):
    result = plugin.get_setting(id, False)
    if result != '0':
        return result

@plugin.action()
def root():
    resp = client().echo()
    if not resp:
        notify(translate("Server {0} is down").format(TORRSERVED_HOST))
        listing = get_listing("noindex")
        return create_listing(listing, category="N/A")
    else:
        listing = get_listing("index")
        category = 'Matrix.{}'.format(resp[2]) if resp[0] == 2 else "v"+str(resp)
        return create_listing(listing, category=category, content='videos')

def get_listing(params, type=None):
    listing = []
    if params == "index":
        listing.append({
            'label': translate("Torrents List"),
            'url': plugin.get_url(action='torrents', mod='list'),
            'icon': addon_img_path("list.png"),
            'is_folder': True
        })
        if plugin.get_setting("use_torlook", True):
          listing.append({
            'label': translate("Search"),
            'url': plugin.get_url(action="search", mod="index"),
            'icon': addon_img_path("search.png"),
            'is_folder': True
          })
        listing.append({
            'label': translate('Open .torrent'),
            'url': plugin.get_url(action='file', mod='open'),
            'icon': addon_img_path("add.png"),
            'is_folder': True,
        })
        listing.append({
            'label': translate('Open all .torrent in dir'),
            'url': plugin.get_url(action='file', mod='opendir'),
            'icon': addon_img_path("add.png"),
            'is_folder': True,
        })
        listing.append({
            'label': translate("Settings"),
            'icon': addon_img_path("settings.png"),
            'url': plugin.get_url(action='settings', mod='read'),
            'is_folder': False,
        })
    elif params == "noindex":
        listing.append({
            'label': translate("Settings"),
            'icon': addon_img_path("settings.png"),
            'url': plugin.get_url(action='settings', mod='open'),
            'is_folder': False
        })
    elif params == "search":
        langD = (('ru', 'russians'), ('en', 'english speaking'), ('fr', 'french'),
               ('de', 'german'), ('it', 'italian'), ('ja', 'japanese'),
               )
        year = time.strftime('%Y') #"2020"
        if type == "movie":
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("Movies"), translate("Cartoons"), translate("per day")),
                'url': plugin.get_url(action='search', mod='trending', type='movie', wtime='day', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("Movies"), translate("Cartoons"), translate("per week")),
                'url': plugin.get_url(action='search', mod='trending', type='movie', wtime='week', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Movies")),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Cartoons")),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Movies"), year),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Cartoons"), year),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            for l, m in langD:
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Movies"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, lang=l, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Cartoons"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='movie', page=1, year=year, lang=l, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
            listing.append({
                "label": translate("New Search"),
                'url': plugin.get_url(action='search', mod="search", type="movie"),
                'icon': addon_img_path("search.png"),
                "is_playable": False,
                'is_folder': True,
            })
        elif type == "tvshow":
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("TV Shows"), translate("Animated series"), translate("per day")),
                'url': plugin.get_url(action='search', mod='trending', type='tvshow', wtime='day', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}, {2} {3}".format(translate("Discover"), translate("TV Shows"), translate("Animated series"), translate("per week")),
                'url': plugin.get_url(action='search', mod='trending', type='tvshow', wtime='week', page=1),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("TV Shows")),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1}".format(translate("Discover"), translate("Animated series")),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("TV Shows"), year),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            listing.append({
                'label': "{0} {1} {2}".format(translate("Discover"), translate("Animated series"), year),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
            })
            for l, m in langD:
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("TV Shows"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, lang=l, ngenres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
              listing.append({
                'label': "{0} {3} {1} {2}".format(translate("Discover"), translate("Animated series"), year, translate(m)),
                'url': plugin.get_url(action='search', mod='discover', type='tvshow', page=1, year=year, lang=l, genres='16'),
                'icon': addon_img_path("top.png"),
                'is_playable': False,
                'is_folder': True,
              })
            listing.append({
                "label": translate("New Search"),
                'url': plugin.get_url(action='search', mod="search", type="tvshow"),
                'icon': addon_img_path("search.png"),
                "is_playable": False,
                'is_folder': True,
            })
        else:
            listing.append({
                "label": translate("Movies"),
                'url': plugin.get_url(action='search', mod="index", type="movie"),
                'icon': addon_img_path("movies.png"),
                "is_playable": False,
                'is_folder': True,
            })
            listing.append({
                "label": translate("TV Shows"),
                'url': plugin.get_url(action='search', mod="index", type="tvshow"),
                'icon': addon_img_path("tv.png"),
                "is_playable": False,
                'is_folder': True,
            })
            listing.append({
                'label': translate("Torrents"),
                'url': plugin.get_url(action='search', mod="torrent"),
                'icon': addon_img_path("search.png"),
                'is_playable': False,
                'is_folder': True,
            })
            type='video'

        with plugin.get_storage('historySearch'+type) as storage:
            i = 0
            while i < 10:
                try:
                    if storage['title{0}'.format(i)]:
                        listing.append({
                            'label': storage['title{0}'.format(i)],
                            'url': plugin.get_url(action='search', mod="search", type=type, query=storage['title{0}'.format(i)]) if type != 'video' else plugin.get_url(action='search', mod="torrent", type=type, query=storage['title{0}'.format(i)]),
                            'icon': addon_img_path("search.png"),
                            'is_playable': False,
                            'is_folder': True,
                            "context_menu": [(
                                translate("Remove query"),
                                "RunPlugin(%s)" % plugin.get_url(action="search", mod="history", type=type, delete='title{0}'.format(i)),
                            )]
                        })
                except:
                    pass
                finally:
                    i += 1
    return listing

@plugin.action('file')
def open_file(params):
    dialog = xbmcgui.Dialog()
    if params.link and params.link.startswith('http'):
        import requests
        r = requests.get(params.link)
        if r.ok:
            data = r.content
            if not data:
                return
            pFile = 'special://temp/torrserve.torrent'
            tFile = translatePath(pFile)
            rtFile = decode_string(tFile)
            with open(rtFile, 'wb') as f:
                f.write(data)
        else:
            return
    else:
        tFile = dialog.browseSingle(1, translate('Select torrent file'), 'files', '.torrent')
        #dialog.ok('test', tFile)
    if tFile != '':
        import xbmcvfs

        listing = []
        tfiles = [tFile]
        if params.mod == 'opendir':
            dir = tFile[:tFile.rfind('/')]
            dirs, files = xbmcvfs.listdir(dir)
            files.sort()
            #dialog.ok('test', str_type(files))
            tfiles = [os.path.join(dir, i) for i in files if '.torrent' in i.lower()]
        for tfile in tfiles:
            tf = xbmcvfs.File(tfile)
            i = tf.read()
            tf.close()
            metainfo = bencode.bdecode(i)
            infohash = hashlib.sha1(bencode.bencode(metainfo['info'])).hexdigest()  # type: ignore
            tr = [metainfo['announce']]
            if 'announce-list' in metainfo:
                for t in metainfo['announce-list']:
                    if t:
                        tr.append(t.pop())
            params = {
                'dn': metainfo['info']['name'],
                'tr': tr,
            }
            magneturi = 'magnet:?xt=urn:btih:{0}&{1}'.format(str(infohash).upper(), urlencode(params, True))
            listing.append({
                'label': metainfo['info']['name'],
                'url': plugin.get_url(action='gotInfo', magnet=magneturi),
                'icon': addon_img_path("magnet.png"),
                'is_folder': True,
                "context_menu": [(
                    translate("Add to DB"),
                    "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="add", magnet=magneturi),
                )]
            })
        return create_listing(listing, cache_to_disk=True, category=tFile)

def pNone(p):
    return p if p !='None' else None

@plugin.action("search")
def search(params):
    poster = None
    listing = []
    if params.mod == "index":
        return create_listing(get_listing("search", params.type))
    elif params.mod == "history":
        with plugin.get_storage('historySearch'+params.type) as storage:
            storage[params.delete] = None
        xbmc.executebuiltin("Container.Refresh")
        return
    elif params.mod in ("discover","trending"):
        result = {}
        page = params.page
        query = pNone(params.year)
        lang = pNone(params.lang)
        genres = pNone(params.genres)
        ngenres = pNone(params.ngenres)
        nextPage = int(page) + 1
        if params.type == "movie":
            if params.mod == "discover":
               result = tmdb.discover_movie(query, page, lang, genres, ngenres)
            else:
               result = tmdb.trending(mtype="movie", wtime=params.wtime, page=page)
            movie_ids = result['results']
            for movie in movie_ids:
                item = makeMovieItem(movie)
                item.update({'url': plugin.get_url(action='search',
                                                    mod="torrent",
                                                    query=u'{} {}'.format(movie['original_title'], str(movie['release_date'][:4])),
                                                    type="movie",
                                                    id=movie['id']),
                    'context_menu': [( translate('Search title and year'),
                        'Container.Update(%s)' % plugin.get_url(action='search',
                                                            mod="torrent",
                                                            query=u'{} {}'.format(movie['title'], str(movie['release_date'][:4])),
                                                            type="movie",
                                                            id=movie['id'],
                                                            title='true')),
                                    ( translate('Search title'),
                        'Container.Update(%s)' % plugin.get_url(action='search',
                                                            mod="torrent",
                                                            query=u'{} {}'.format(movie['title'], str(movie['release_date'][:4])),
                                                            type="movie",
                                                            id=movie['id'],
                                                            title='onlyname'),
                    )],
                })
                listing.append(item)
        elif params.type == "tvshow":
            if params.mod == "discover":
               result = tmdb.discover_tvshow(query, page, lang, genres, ngenres)
            else:
               result = tmdb.trending(mtype="tv", wtime=params.wtime, page=page)
            shows_ids = result['results']
            for show in shows_ids:
                item = makeTvShowItem(show)
                item.update({'url': plugin.get_url(action='search', mod="torrent", query=show['original_name'], type="tvshow", id=show['id']),
                'context_menu': [( translate('Search title'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=show['name'], type="tvshow", id=show['id'], title='true'),
                    )],
                })
                listing.append(item)
        maxPage = int(result.get('total_pages', '1'))
        if nextPage <= maxPage:
           listing.append({
              'label': "{0} / ({1})".format(translate("Next page ({0})").format(nextPage), maxPage),
              'icon': addon_img_path("nextpage.png"),
              'url': plugin.get_url(action='search', mod='discover', type=params.type, page=nextPage, year=query, lang=lang, genres=genres, ngenres=ngenres)
           })
        return create_listing(listing,
                              category="{0}: {1}".format(translate("Discover"), query),
                              cache_to_disk=True,
                              content="{0}s".format(params.type),
                              view_mode=getViewMode('search_view'))
    elif params.mod == "search":
        result = {}
        query = params.query
        dialog = xbmcgui.Dialog()
        if not query:
            query = dialog.input("Yohoho", type=xbmcgui.INPUT_ALPHANUM)
            if query == "":
                return
            with plugin.get_storage('historySearch'+params.type) as storage:
                storage['title9'] = storage.get('title8')
                storage['title8'] = storage.get('title7')
                storage['title7'] = storage.get('title6')
                storage['title6'] = storage.get('title5')
                storage['title5'] = storage.get('title4')
                storage['title4'] = storage.get('title3')
                storage['title3'] = storage.get('title2')
                storage['title2'] = storage.get('title1')
                storage['title1'] = storage.get('title0')
                storage['title0'] = query
        if params.type == "movie":
            result = tmdb.search_movies(query, params.page)
        else:
            result = tmdb.search_tv_shows(query, params.page)
        maxPage = int(result['total_pages'])
        nextPage = int(result['page'])+1
        movie_ids = result['results']
        for movie in movie_ids:
            if params.type == "movie":
                item = makeMovieItem(movie)
                item.update({'url': plugin.get_url(action='search', mod="torrent", query=movie['original_title']+" "+str(movie['release_date'][:4]), type="movie", id=movie['id']),
                'context_menu': [( translate('Search title and year'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['title']+" "+str(movie['release_date'][:4]), type="movie", id=movie['id'], title='true') ),
                    ( translate('Search title'),
                    'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['title']+" "+str(movie['release_date'][:4]), type="movie", id=movie['id'], title='onlyname'),
                    )],
                })
                listing.append(item)
            elif params.type == "tvshow":
                if movie['number_of_seasons'] > 0:
                    item = makeTvShowItem(movie)
                    item.update({
                        'url': plugin.get_url(action='search', mod="torrent", query=movie['original_name'], type="tvshow", id=movie['id']),
                        'context_menu': [( translate('Search title'),
                            'Container.Update(%s)' % plugin.get_url(action='search', mod="torrent", query=movie['name'], type="tvshow", id=movie['id'], title='true'),
                            )],
                    })
                    listing.append(item)
        if nextPage <= maxPage:
           listing.append({
             'label': "{0} / ({1})".format(translate("Next page ({0})").format(nextPage), maxPage),
             'icon': addon_img_path("nextpage.png"),
             'url': plugin.get_url(action='search', mod='search', type=params.type, query=query, page=nextPage)
           })
        return create_listing(listing,
                              category="{0}: {1}".format(translate("Search"), query),
                              cache_to_disk=True,
                              content="{0}s".format(params.type),
                              view_mode=getViewMode('search_view'))
    elif params.mod == "torrent":
        from .navigation_search import search_torrent
        return search_torrent(plugin, params)


@plugin.action('descript')
def descript(params):
    gui = GuiTextViewer('DialogTextViewer.xml', sys.argv[0], descript=params.text, title=translate("Description"))
    gui.doModal()
    del gui


class GuiTextViewer(xbmcgui.WindowXMLDialog):
    def __init__(self, *args, **kwargs):
        self.descript = kwargs['descript']
        self.title = kwargs['title']
        xbmcgui.WindowXMLDialog.__init__(self, *args, **kwargs)

    def onInit(self):
        from xbmcgui import Control
        #lang = Lang()
        self.getControl(1).setLabel(self.title)     # type: ignore
        self.getControl(5).setText(self.descript)   # type: ignore

    def onFocus(self, control):
        pass


def checkMagnet(magneturi):
    kinozalurl = str(plugin.get_setting("kinozal_url"))
    if not magneturi:
        pass
    elif '://torlook.info/dl/' in magneturi:
        html = decode_string(http_request('', host=magneturi, ljs=False))
        r = re.compile(r"(magnet:.+?)'>").search(html)
        if not r:
            return
        magneturi = r.group(1)
    elif '://kinozal-tv.appspot.com/magnet?' in magneturi or (kinozalurl.strip() !="" and '://'+kinozalurl.strip()+'/magnet?' in magneturi):
        from searcher.scrapers.kinozal import get_magnet as kz_magnet
        magneturi = kz_magnet(magneturi.split('magnet?')[1])
    elif magneturi.startswith('http'):
        data = http_request('', host=magneturi, ljs=False)
        if not data:
            return
        metainfo = None
        try:
            metainfo = bencode.bdecode(data)
        except BaseException as e:
            if data.find('keywords" content="nnm-club,') != -1:

                r = re.compile(r'name="redirect"\s+value="([^"]+)"').search(data)
                if not r:
                    return
                redirect = r.group(1)
                from searcher.scrapers.nnmclub import Tracker
                login = plugin.get_setting("nnmclub_login")
                password = plugin.get_setting("nnmclub_password")
                if login == "" or password == "":
                    notify("Нужен логин и пароль NNMClub для просмотра раздачи")
                    return
                data2 = Tracker().Login(login, password, redirect)
                if data2.find('keywords" content="nnm-club,') != -1:
                    notify("Неверный логин и пароль от NNMClub")
                    return

                metainfo = bencode.bdecode(data2)
            else:
                notify(str(e))

        if not metainfo:
            return

        infohash = hashlib.sha1(bencode.bencode(metainfo['info'])).hexdigest() # type: ignore
        tr = [metainfo['announce']]
        if 'announce-list' in metainfo:
            for t in metainfo['announce-list']:
                if t: tr.append(t.pop())
        mparams = {
        'dn': metainfo['info']['name'],
        'tr': tr,
        }
        magneturi = 'magnet:?xt=urn:btih:{0}&{1}'.format(str(infohash).upper(), urlencode(mparams, True))
    return magneturi

def makeTorrentsList():
    #request = int(plugin.get_setting("without_info", True))
    #response = client("/torrent/shortlist", post_data={"Request": request, "Info": 1})
    #if response is None:

    response = client().list()  #("/torrent/list", post_data={"Request": request})
    for torrent_item in response:
        engine = client(hash=torrent_item['Hash'])

        title = torrent_item.get('title')
        label = parseName( title if title else torrent_item['Name'])
        size = torrent_item.get('Length')
        if size:
            size = humanizeSize(size)
        item = {
            "label": u"[{0}] {1}".format(size, label) if size else label,
            "url": plugin.get_url(action="torrents", mod="files", hash=torrent_item['Hash']),
            "icon": addon_img_path("magnet.png"),
            "context_menu": [(
                translate("Delete from DB"),
                "RunPlugin(%s)" % plugin.get_url(action="torrents", mod="delete", hash=torrent_item["Hash"]),
            ), (
                translate("Open TAM"),
                "RunPlugin(%s)" % plugin.get_url(action="tam", hash=torrent_item["Hash"], name=label),
            )],
        }

        info = None
        data = torrent_item.get('data', torrent_item.get('Info'))
        if data:
            try:
                info = json.loads(data)
            except json.JSONDecodeError:
                data = None

        poster = torrent_item.get('poster')
        if poster:
            art = {
                'thumb': poster,
                'poster': poster,
            }
            if info:
                art['fanart'] = info.get('backdrop_path')
        else:
            art = None # engine.get_art()

        if art:
            log('Has art')
            log(str_type(art))
            item.update({'art': art})
            if 'thumb' in art:
                item['icon'] = art['thumb']

        if data:
            video_info = engine._get_video_info_from_data(data)
        else:
            video_info = None #engine.get_video_info()

        if video_info:
            log('Has video info')
            log(str_type(video_info))
            if 'info' in item and item['info'].get('video'):
                video_info['mediatype'] = "movie"
            item['info'] = { 'video': video_info }

        if 'Info' in torrent_item and torrent_item['Info'] != "{}":
            i = json.loads(torrent_item['Info'])
            if 'descript' in i:
                item['context_menu'].insert(0,(
                    translate("Description"),
                    "RunPlugin(%s)" % plugin.get_url(action="descript", text=i['descript']),
                ))

            if 'kodi' in i:
                if 'info' in i['kodi'] and i['kodi'].get('info'):
                    item['info'] = { 'video': i['kodi']['info'] }
                if 'cast' in i['kodi'] and i['kodi'].get('cast'):
                    item['cast'] = i['kodi']['cast']
        yield item

def makeFileList(hash):
    onlymedia = plugin.get_setting("only_media", True)
    engine = client(hash=hash)
    engine._wait_for_data()

    video_info = engine.get_video_info()
    art = engine.get_art()

    files = engine.files()
    for f in files:
        log(str_type(f))

        if onlymedia and checkMime(f['path']) == "*/*":
            continue

        item = {
            "label": parseName(f['path'].split('/')[-1]),
            "url": make_play_url(hash=hash, sort_index=f['file_id']),
            "is_playable": True,
            "info": {"video": video_info}
        }
        if art:
            item.update({'art': art})

        yield item

@plugin.action("torrents")
def torrents(params):
    listing = []
    view_mode = None
    if params.mod == "list":
        listing = makeTorrentsList()
    elif params.mod == "files":
        listing = makeFileList(params.hash)
        view_mode = getViewMode('files_view')
    elif params.mod == "add":
        magneturi = checkMagnet(params.magnet)
        import ast
        item = ast.literal_eval(params.item)

        info = item['info']['video']
        title = u'{} / {} ({})'.format( info['title'], info['originaltitle'], info['year'])
        poster = item.get('art', {}).get('poster')

        engine = client()
        engine.add(uri=magneturi, title=title, poster=poster, data=params.item)

        notify(translate("Saved!"))
    elif params.mod == "delete":
        client(hash=params.hash).rem()
        notify(translate("Deleted!"))
        xbmc.executebuiltin("Container.Refresh")

    if listing:
        create_listing(listing, content="videos", category="Torrents", view_mode=view_mode)

@plugin.action()
def settings(params):
    plugin.addon.openSettings()
    '''
    if params.mod == "read":
        if getVerTS() != 1:
            plugin.addon.openSettings()
            return
        resp = client("/settings/read", post_data={"read": 1})
        for k, v in resp.items():
            if k == "CacheSize" or k == "PreloadBufferSize":
                v = (v / 1024) / 1024
            plugin.set_setting(k, str(v).lower())
        plugin.addon.openSettings()
        while settingsIsOpen():
            continue

        jset = {
            "CacheSize": plugin.get_setting("CacheSize", True) * 1024 * 1024,
            "PreloadBufferSize": plugin.get_setting("PreloadBufferSize", True) * 1024 * 1024,
            "RetrackersMode": plugin.get_setting("RetrackersMode", True),
            "DisableTCP": plugin.get_setting("DisableTCP", True),
            "DisableUTP": plugin.get_setting("DisableUTP", True),
            "DisableUPNP": plugin.get_setting("DisableUPNP", True),
            "DisableDHT": plugin.get_setting("DisableDHT", True),
            "DisableUpload": plugin.get_setting("DisableUpload", True),
            "Encryption": plugin.get_setting("Encryption", True),
            "DownloadRateLimit": plugin.get_setting("DownloadRateLimit", True),
            "UploadRateLimit": plugin.get_setting("UploadRateLimit", True),
            "ConnectionsLimit": plugin.get_setting("ConnectionsLimit", True),
            "PeersListenPort": plugin.get_setting("PeersListenPort", True)
        }
        for i in ("EnableIPv6","DhtConnectionLimit","TorrentDisconnectTimeout","M3UContentType","SupportMode",
                  "DisableRealId","RequestStrategy","BuiltinRetrackers","NewtrackonRetrackers","MigrateDB",
                  "NgosangallipRetrackers","MaxRunTorrents","DelMaxRunTorrent","RemoveViewed","RemoveInfo",
                  "DisableCtrlViewed"):
               if i in resp: jset[i] = plugin.get_setting(i, True)
        if not resp == jset:
            resp = client("/settings/write", post_data=jset)
            if resp == "Ok":
                notify(translate("Settings saved! Restart service"))
                client.restart()
                xbmc.executebuiltin("Container.Refresh")
            else:
                notify(translate("Settings not saved!"))
                plugin.log_error(repr(resp))
    elif params.mod == "open":
        plugin.addon.openSettings()
    '''

def getHash(mag):
    if mag.startswith("magnet%"):
         mag = unquote_plus(mag)
    return mag[20:60]


def prebuffer(engine):
    pDialog = OurDialogProgress()
    pDialog.create("TorrServer",
            translate("Wait for info..."),
            translate("Connected: {0} | Active: {1} | Total: {2}").format(0, 0, 0))

    while True:
        if pDialog.iscanceled() :
            pDialog.close()
            engine.drop()
            return False

        time.sleep(0.5)
        try:
            st = engine.stat()
        except BaseException as e:
            log('continue...')
            log(str_type(e))
            continue

        if 'message' in st:
            continue

        stat_id = st.get('TorrentStatus')

        if stat_id > 2 and engine.is_v2:
            pDialog.close()
            return True

        downSpeed = humanizeSize(st.get('DownloadSpeed', 0))
        preloadedBytes = st.get('PreloadedBytes', 0)
        preloadSize = st.get('PreloadSize', 0)
        line2 = translate("Connected: {0} | Active: {1} | Total: {2}").format(
            st.get('ConnectedSeeders', 0),
            st.get('ActivePeers', 0),
            st.get('TotalPeers', 0))

        line3 = u"D: {0}/{3} [{1}/{2}]".format(
            downSpeed,
            humanizeSize(preloadedBytes),
            humanizeSize(preloadSize),
            's'
        )

        if preloadSize > 0 and preloadedBytes > 0:
            prc = preloadedBytes * 100 / preloadSize
            if prc > 100:
                prc = 100
            pDialog.update(int(prc), line2, line3)

            #stat_s = st.get('TorrentStatusString')

            if  (preloadedBytes >= preloadSize) or \
                (prc > 0 and stat_id != 2): # 2 - 'Torrent preload'
                pDialog.close()
                return True


def get_torrspy_base_path():
    try:
        torr_spy = xbmcaddon.Addon('script.service.torrspy')
        return torr_spy.getSetting('base_path')
    except RuntimeError:
        pass

def load_info_from_data(info_str, hash):
    log('load_info_from_data')
    try:
        torr_spy = xbmcaddon.Addon('script.service.torrspy')

        base_path = torr_spy.getSetting('base_path')
        path = filesystem.join(base_path, '.data', '{}.{}.json'.format(hash, info_str))

        log('load_info_from_data path is {}'.format(path))

        if filesystem.exists(path):
            log('Video info was found in {}'.format(path))

            import json
            with filesystem.fopen(path, 'r') as data:
                info = json.load(data)
                return info
    except RuntimeError:
        pass

    return {}

def load_info(info_str, hash, kodi_db):
    info = load_info_from_data(info_str, hash)
    if kodi_db:
        pass

    return info

def _play(hash, sort_index, params):
    log(hash)
    engine = client(hash=hash, log=log)
    engine.start(sort_index)
    #subtitles = loadsubtitles(hash, params.link),
    success = prebuffer(engine)
    if success:
        player = xPlayer(hash=hash, index=sort_index)
        playable_url = engine.play_url(sort_index)

        strm_path = None
        if 'strm_path' in params:
            torrspy_base_path = get_torrspy_base_path()
            strm_path = filesystem.join(torrspy_base_path, params['strm_path'])

        item = xbmcgui.ListItem(path=playable_url)

        resume_time = 0
        filedetails = {}
        if strm_path:
            from vdlib.kodi.jsonrpc_requests import Files
            result = Files.GetFileDetails(file=strm_path, media='video',
                                            properties=['playcount', 'resume'])
            if result:
                filedetails = result['filedetails']
                resume_time = filedetails.get('resume', {}).get('position', 0)
        log('resume_time is {}'.format(resume_time))

        xbmcplugin.setResolvedUrl(int(sys.argv[1]), success, item)

        while not player.isPlaying() and not xbmc.Monitor().abortRequested():
            xbmc.sleep(100)

        log('!!!!!!!!!!!!!!!!! Start PLAYING !!!!!!!!!!!!!!!!!!!!!')

        if resume_time:
            while player.isPlaying() and player.getTime() < 20:
                if player.isPlaying() and player.getTime() > 2:
                    log('Try change time pos')
                    player.seekTime(resume_time)
                    xbmc.sleep(5000)
                xbmc.sleep(1000)

        # Wait until playing finished or abort requested
        while player.isPlaying() and not xbmc.Monitor().abortRequested():
            xbmc.sleep(1000)

        log('!!!!!!!!!!!!!!!!! END PLAYING !!!!!!!!!!!!!!!!!!!!!')


@plugin.action("play")
def play(params):
    autoremove = params.get("autoremove")

    _play(params.hash, int(params.sort_index), params)

    if autoremove:
        log(f"autoremove: {autoremove}")

        xbmc.sleep(5 * 1000)
        engine = client(hash=params.hash)
        engine.rem()


def make_play_url(hash: str, sort_index: int, save_in_db: bool = True) -> str:
    if save_in_db:
        return plugin.get_url(action="play", hash=hash, sort_index=sort_index)
    else:
        return plugin.get_url(action="play", hash=hash, sort_index=sort_index, autoremove=1)


@plugin.action('play_strm')
def play_strm(params):
    from torrserve_stream import Engine

    play_url = params.play_url
    hash = Engine.extract_hash_from_play_url(play_url)
    sort_index = int(params.sort_index)

    _play(hash, sort_index, params)


@plugin.action("gotInfo")
def gotInfo(params):
    magneturi = None
    try:
        magneturi = checkMagnet(params.magnet)
    except:
        import vsdbg
        vsdbg.breakpoint()

    if not magneturi:
       return

    pDialog = OurDialogProgress()
    pDialog.create("TorrServer", translate("Wait for info..."))
    listing = []
    success = False
    i = 0

    import datetime
    first_time = datetime.datetime.now()

    engine = client()
    engine.add(magneturi, poster=params.get('poster'))

    def make_item(file):
        save_in_db: bool = plugin.get_setting("save_in_db", True)
        url = make_play_url(
            hash=getHash(magneturi),
            sort_index=file['file_id'],
            save_in_db=save_in_db)

        item = {
            "label": file['path'].split('/')[-1],
            "url": url,
            "is_playable": True,
            "info": {"video": {
                'size': file['size'],
            }}
        }
        if params.poster:
            item.update({'art': {
                'thumb': params.poster,
                'poster': params.poster,
            }})
        return item

    while not pDialog.iscanceled():
        xbmc.sleep(500)
        stat = engine.stat()
        #if stat is None or len(stat['FileStats']) == 0:
        if stat['TorrentStatusString'] != 'Torrent working':
            xbmc.sleep(500)
            now_time = datetime.datetime.now()
            difference = now_time - first_time
            mins, secs = divmod(difference.seconds, 60)
            procents = difference.seconds * 2
            if difference.seconds > 100:
                pDialog.update(procents, 'Информация о [B]{2}[/B] не получена за {0:02d} : {1:02d} с.'.format(
                                                mins,
                                                secs,
                                                stat.get('Name', 'раздаче')),
                                    'Видимо это мертвая раздача и отсутствуют пиры.')
            else:
                pDialog.update(procents, 'Пытаемся подключиться к раздаче [B]{0:02d} : {1:02d}[/B] с.'.format(
                                                mins, secs))
            continue
        else:
            files = engine.files()
            for file in files:
                if file['path'].find('/BDMV/') > 0:
                    if int(file['size']) > 1073741824 or file['path'].find('/BDMV/index.bdmv') > 0:
                        listing.append(make_item(file))
                elif checkMime(file['path']) in ("video/*", "audio/*"):
                    listing.append(make_item(file))
            success = len(listing) > 0
            pDialog.close()
            break

    if success:
        return create_listing(listing, content="videos", category="Файлы", succeeded=success)
    else:
        return create_listing(listing, succeeded=success)

def cleanname(s):
    for i in (' ','%','!','*',"'",'(',')',';',':','@','&','=','+','$',',','/','?','#','[',']','~','"','{','}'):
         s = s.replace(i,'_')
    s = s.replace('__','_')
    return s


def loadsubtitles(hash=None, link=None, fileid=None):
    if hash and (link or fileid) and plugin.get_setting('use_subtitles', True):
        log('-- loadsubtitles start --')
        success = False
        global self_prev_name, self_rus
        self_prev_name = ''
        self_rus = ''

        def cfname(name, rus=''):
            global self_prev_name, self_rus
            if '/' in name: name = name.split('/')[-1]
            if (name == self_prev_name) and (rus == self_rus): name = name[:name.rfind('.')] + u'_2_' + name[name.rfind('.'):]
            self_prev_name = name
            self_rus = rus
            if rus and (rus.lower() not in name.lower()): name = name[:name.rfind('.')] + rus + name[name.rfind('.'):]
            elif rus and (rus.lower() in name.lower()): name = name.replace(rus.lower(), rus).replace(rus.upper(), rus)
            return name

        if link:
            fname = link.split('/')[-1]
            if '/preload/' not in link: fname = fname.split('?')[0]
            fname = unquote_plus(fname)
        stat = {}
        counter = 0
        pdialog = OurDialogProgress()
        pdialog.create('TorrServer', translate('Start find subtitles...'))
        while not stat.get('FileStats'):
            if pdialog.iscanceled():
                pdialog.close()
                return False
            prc = counter*100/120
            pdialog.update(prc, translate('Find subtitles...'))
            stat = client(hash=hash).stat()
            if stat is None:
                stat = {}
            if counter > 120:
                pdialog.close()
                return False
            counter += 1
            time.sleep(0.5)

        self_filestats = stat['FileStats']
        ind = 0
        self_index = ind
        findfullname = None
        for f in self_filestats:
            if fileid:
                if int(f['Id']) == int(fileid):
                    findfullname = f['Path']
                    self_index = ind
            elif link:
                if cleanname(f['Path']) == fname:
                    findfullname = f['Path']
                    self_index = ind

            ind += 1
            if not findfullname:
                pdialog.close()
                return False
        findname = findfullname
        if findname and '/' in findname:
            findname = findname.split('/')[-1]
        findname = findname[:findname.rfind('.')]

        index = 0
        temp_list = []
        for i in self_filestats:
            name = i['Path']
            if findname in name:
                if index != self_index:
                    if '.' in name:
                        ext = name.split('.')[-1]
                        if ext in ('srt', 'ass', 'ssa', 'smi'):
                            fileid = int(i['Id'])
                            temp_list.append( (index, fileid, name) )
            index += 1
        log('--sort subtitles--')
        if temp_list !=[]:
            temp_rus = []
            temp_eng = []
            temp_other = []
            del_list = []
            for f in range(len(temp_list)):
                i = temp_list[f]
                n = i[2].lower()
                if '/rus/' in n:
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    del_list.insert(0, f)
                elif '/eng/' in n:
                    temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                    del_list.insert(0, f)
            for i in del_list: del temp_list[i]
            for i in temp_list:
                n = i[2].lower()
                if ('.rus' in n) or ('_rus' in n) or ('_ru.' in n):
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                elif ('.eng' in n) or ('_eng' in n): temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                elif 'rus ' in n:
                    if ('.forc' in n) or ('_forc' in n) or ('rus forc' in n):
                        temp_rus.insert( 0, (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                    else:
                        temp_rus.append( (i[0], i[1], cfname(i[2], '.Rus'), i[2] ) )
                elif 'eng ' in n: temp_eng.append( (i[0], i[1], cfname(i[2], '.Eng'), i[2] ) )
                else: temp_other.append( (i[0], i[1], cfname(i[2]), i[2] ) )
            if temp_rus == [] and temp_other:
                i = temp_other[0]
                temp_rus.append( (i[0], i[1], cfname(i[3], '.Rus'), i[3] ) )
                del temp_other[0]
            temp_l = []
            temp_l.extend(temp_rus)
            temp_l.extend(temp_eng)
            temp_l.extend(temp_other)

            subtitles = []
            counter = 1
            for i in temp_l:
                uname = "/torrent/view/"+str(hash).lower()+"/"+quote_plus( cleanname(i[3]) )
                prc = counter*100/len(temp_l)
                pdialog.update(prc, translate('Load subtitles {0} / {1}').format(counter,len(temp_l)) )
                data = client(uname)
                if data:
                    class Handler:
                        @staticmethod
                        def path(*path):
                            p = [translatePath('special://temp')]
                            p.extend(path)
                            return os.path.join(*p)
                    sdir  = Handler().path('subtitles_torrserve')
                    if not os.path.isdir(sdir): os.mkdir(sdir)
                    fname = Handler().path('subtitles_torrserve', i[2])
                    with open(fname, 'wb') as file:
                        file.write(data)
                    subtitles.append(fname)
                else:
                    log('error loading subtitles!')
                    success = False
                    break
            if subtitles !=[]: success = subtitles
        else:
            log('subtitles not found!')
        log('-- loadsubtitles stop --')
        pdialog.close()
        return success
    return False


@plugin.action('library')
def library(params):
    from vdlib.torrspy.detect import is_video

    if params.mod == 'save':
        magneturi = checkMagnet(params.magnet)
        if not magneturi:
           return

        import ast
        item = ast.literal_eval(params.item)
        info = item['info']['video']
        title = u'{} / {} ({})'.format( info['title'], info['originaltitle'], params.year)
        poster = item.get('art', {}).get('poster')

        engine = client()
        engine.add(uri=magneturi, title=title, poster=poster, data=params.item)
        engine._wait_for_data()
        torrent_files = [i for i in engine.files() if is_video(i['path'])]

        if info.get('mediatype') == "movie":
            from vdlib.torrspy.strm_utils import save_movie_strm

            if torrent_files:
                torrent_files = sorted(torrent_files, key=lambda i: i['size'], reverse=True)
                sort_index = torrent_files[0]['file_id']
                play_url = engine.play_url(sort_index)
                name = save_movie_strm(play_url, sort_index, info['originaltitle'], params.year)
                notify(name)
        elif info.get('mediatype') == "tvshow":
            from vdlib.torrspy.strm_utils import save_tvshow_strms
            imdb = info.get('imdbnumber')
            save_tvshow_strms(info['title'], info['originaltitle'], params.year, imdb, engine)


        xbmc.executebuiltin('UpdateLibrary("video")')

@plugin.action('tam')
def tam(params):
    import torrserve.totam as totam
    if params.magnet:
         url = checkMagnet(params.magnet)
    else:
         url = 'magnet:?xt=urn:btih:{0}&dn={1}'.format(str(params.hash).upper(), quote_plus(params.name))
    totam.opentam(url)

def run():
    plugin.run()
